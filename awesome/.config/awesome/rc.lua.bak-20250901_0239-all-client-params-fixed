--------------------------------------------------
-- Milkiis rc.lua                                --
-- https://github.com/mxmilkiib/dotfiles        --
--------------------------------------------------

-- 🧪 TESTING METHODS:
-- 
-- BASIC SYNTAX CHECK (no libraries):
--   lua -e "dofile('rc.lua')" 2>&1 | head -10
--   (Expected: "module 'gears' not found" - this is normal outside AwesomeWM)
--
-- FULL ENVIRONMENT TEST (with AwesomeWM libraries):
--   awesome -c ~/.config/awesome/rc.lua --check
--   (Tests complete configuration with all libraries loaded)
--
-- XEPHYR TEST ENVIRONMENT:
--   Xephyr :1 -ac -br -noreset -screen 1152x720 &
--   DISPLAY=:1.0 awesome -c ~/.config/awesome/rc.lua
--   (Runs AwesomeWM in virtual display for safe testing)
--
-- LINTING WITH LUA CHECK:
--   luarocks install luacheck
--   luacheck rc.lua --no-max-line-length
--   (Static analysis for common Lua issues)
--
-- DEBUG MODE:
--   awesome -c ~/.config/awesome/rc.lua --debug
--   (Runs with debug output for troubleshooting)
--
-- NOTE: The "module 'gears' not found" error is expected when testing
-- outside the AwesomeWM environment. Use awesome --check for full validation.


-- // MARK: OVERVIEW
-- ################################################################################
-- ██████╗ ██╗██████╗ ███████╗ ██████╗████████╗ ██████╗ ██████╗ ██╗   ██╗
-- ██╔══██╗██║██╔══██╗██╔════╝██╔════╝╚══██╔══╝██╔═══██╗██╔══██╗╚██╗ ██╔╝
-- ██║  ██║██║██████╔╝█████╗  ██║        ██║   ██║   ██║██████╔╝ ╚████╔╝ 
-- ██║  ██║██║██╔══██╗██╔══╝  ██║        ██║   ██║   ██║██╔══██╗  ╚██╔╝  
-- ██████╔╝██║██║  ██║███████╗╚██████╗   ██║   ╚██████╔╝██║  ██║   ██║   
-- ╚═════╝ ╚═╝╚═╝  ╚═╝╚══════╝ ╚═════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝   ╚═╝   
-- ################################################################################
-- CONFIGURATION DIRECTORY OVERVIEW
-- This awesome config contains the following components:
--
-- 📄 MAIN FILES:
--   • rc.lua (166KB, 4145 lines) - This comprehensive configuration file
--   • rc_new.lua (15KB, 307 lines) - Alternative minimal config
--   • quake.lua (5.6KB, 169 lines) - Dropdown terminal (Quake-style)
--   • xrandr.lua (3.5KB, 136 lines) - Multi-monitor display management
--   • test_dialog_sizing.lua (1.5KB, 45 lines) - Dialog sizing test script
--
-- 📚 DOCUMENTATION:
--   • DIALOG_SIZING.md (5.0KB, 171 lines) - Auto-sizing for all dialog types
--   • CENTERWORK_ADAPTIVE_README.md (2.8KB, 67 lines) - Custom layout behavior
--   • LAYOUT_ICONS_README.md (4.5KB, 126 lines) - Complete icon reference
--
-- 🎨 THEMING:
--   • milktheme/ - Custom theme with backgrounds, icons, and styling
--
-- 🏗️ LAYOUT ENGINES:
--   • bling/ - Modern layouts (deck, horizontal, equalarea, vertical, mstab, centered)
--   • lain/ - Classic layouts (centerwork, cascade, termfair) + utilities
--   • treetile/ - Hierarchical window arrangement
--   • awesome-workspace-grid/ - Grid-based workspace management
--
-- 🎮 WINDOW MANAGEMENT:
--   • collision/ - Vim-like directional focus navigation
--   • awesome-switcher/ - Alt-Tab application switcher with previews
--   • cyclefocus/ - Advanced focus cycling mechanisms
--   • tyrannical/ - Rule-based dynamic tagging system
--   • revelation/ - OSX-style window exposé overview
--
-- 📱 WIDGETS & STATUS:
--   • battery-widget/ - Visual battery status and charging indicators
--   • media-player-widget/ - Media controls and track information
--   • awesome-wm-widgets/ - Widget collection framework
--
-- 🔌 SYSTEM INTEGRATION:
--   • freedesktop/ - XDG menu integration and .desktop file support
--   • gobo/ - Custom system integration utilities
--   • thrizen/ - Additional system tools
--   • plugins/ - Custom extensions (xrandr + media-player)
--
-- 🗂️ BACKUP ARCHIVE (10 generations):
--   • rc.lua.bak through rc.lua.bak8 - Complete development history
--   • Evolution: 568 lines → 4,145 lines (22KB → 166KB)
--
-- Total: 20+ layouts, 5 focus systems, comprehensive widget ecosystem,
-- deep system integration, and methodical configuration evolution.
--
-- ⚠️  INTENTIONALLY DISABLED FEATURES (commented out by choice):
-- NAVIGATION ALTERNATIVES:
--   • awesome-switcher - Alt-Tab application switcher with previews
--   • gobo.awesome.alttab - Alternative Alt-Tab implementation 
--   • revelation - OSX-style window exposé overview
--   • awesomewm-vim-tmux-navigator - Cross-app (Vim/Tmux) navigation
--
-- LAYOUT EXTENSIONS:
--   • tyrannical + shortcuts - Dynamic desktop tagging system
--   • dovetail, thrizen, leaved - Alternative layout scripts
--   • fenetre - Titlebar customization framework
--   • awesome-workspace-grid - Grid-based tag navigation system
--
-- WIDGETS & UTILITIES:
--   • battery-widget - Visual battery status and charging indicators
--   • xrandr - Multi-monitor display management interface
--   • mpris_widget/media-player - Media controls and track information
--   • smart_borders - Automatic border width control
--
-- OPTIONAL BEHAVIORS:
--   • awful.hotkeys_popup.keys - Extended hotkey help system
--   • freedesktop desktop icons - Desktop icon integration
--   • Sloppy focus - Focus follows mouse behavior
--   • Alternative client rules, placement, and titlebar processing
--
-- NOTE: These features are available but intentionally disabled for current workflow.
--
-- 🔍 SUBDIRECTORY STATUS:
-- ✅ HEALTHY: collision/, bling/, lain/, milktheme/, tyrannical/, awesome-workspace-grid/
-- ✅ FUNCTIONAL: treetile/, freedesktop/, revelation/, battery-widget/, media-player-widget/
-- ⚠️  UNKNOWN: gobo/ (directory access issues - may need investigation)
-- ✅ EMPTY: awesome-wm-widgets/ (placeholder for additional widgets)
-- 📝 PLUGINS: plugins/ contains xrandr.lua + media-player/ subdirectory
-- ################################################################################



-- todo outline (work-in-progress cleanups)
-- - dnd hover styling state management
--   lines ~2656–2678: refactor `awesome_dnd.set_hover` to stop mutating widget bg/fg; compute styling in a single place (update_callback or `apply_tag_hover`) and keep transient state outside widget fields; clear on drag end.
-- - duplicate square generation paths
--   lines 265–297, 316–356: remove one path; keep widget_template imagebox approach; delete `setup_dynamic_squares`/recreations; rely on per-tag signals.
-- - tag square update wiring overlap
--   lines 316–353, 3110–3199, 3567: drop the `setup_dynamic_squares()` call and depend only on create_callback connections.
-- - theme overrides currently in rc.lua
--   lines 233–241: move these to `milktheme/theme.lua` to centralise theme.
-- - hover logic duplication (normal vs dnd)
--   lines 3173–3205 and awesome_dnd.*: add `apply_tag_hover(mode)` and route both paths through it; respect `t.selected`.
-- - notification/test remnants
--   lines ~2700–2900, 3170–3210: strip commented debug; ensure no `naughty.notify` remains.
-- - shimmer system performance/structure
--   lines ~1160–1520 (+ timer init): extract to `plugins/shimmer.lua`; throttle updates; limit to focused screen; reduce per-tick work.
-- - geometry polling for drag hover
--   lines ~2739–2766: remove raw geometry math; use `_is_dnd_tag_target` and mouse signals; keep a minimal fallback if needed.
-- - border animation interaction
--   lines ~1200–1410: implement `pause_border_anim(reason)` / `resume_border_anim(reason)` with ref counting.
-- - global state hygiene
--   lines ~2625+: split `awesome_dnd` into `drag_state`, `config`, `utils`; add `reset_drag_state()`; avoid attaching transient fields on widgets.
-- - tag text style vs shimmer
--   lines ~3151–3154: keep tag text white unless selected; don't let hover/dnd override; audit `beautiful.taglist_fg_*`.
-- - icon square colours/sizing
--   lines 249–260: use theme colours for fill/outline; pull size into a single constant.



-- // MARK: TEST
-- ################################################################################
--  ██████╗ ██████╗ ██████╗ ███████╗
-- ██╔════╝██╔═══██╗██╔══██╗██╔════╝
-- ██║     ██║   ██║██████╔╝███████╗
-- ██║     ██║   ██║██╔══██╗╚════██║
-- ╚██████╗╚██████╔╝██║  ██║███████║
--  ╚═════╝ ╚═════╝ ╚═╝  ╚═╝╚══════╝
-- ################################################################################
-- CORE SETUP - basic awesome configuration foundation and testing setup
-- ################################################################################
-- run in xephyr for testing:
-- Xephyr :1 -ac -br -noreset -screen 1152x720 & DISPLAY=:1.0 awesome -c ~/.config/awesome/rc.lua


-- // MARK: LIBS
-- ################################################################################
-- ██╗     ██╗██████╗ ███████╗
-- ██║     ██║██╔══██╗██╔════╝
-- ██║     ██║██████╔╝███████╗
-- ██║     ██║██╔══██╗╚════██║
-- ███████╗██║██████╔╝███████║
-- ╚══════╝╚═╝╚═════╝ ╚══════╝
-- ################################################################################
-- LIBRARIES - core library imports and external dependencies
-- If LuaRocks is installed, make sure that packages installed through it are found
pcall(require, "luarocks.loader")

-- Standard awesome libraries
local gears = require("gears")
local gmath = require("gears.math")
local awful = require("awful")
require("awful.autofocus")
local wibox = require("wibox")     -- Widget and layout library
local beautiful = require("beautiful") -- Theme handling library
local naughty = require("naughty")   -- Notification library
local menubar = require("menubar")
local hotkeys_popup = require("awful.hotkeys_popup")


-- External libraries
local lain = require("lain")                  -- Layouts, widgets, utilities
local bling = require("bling")                -- Modern layouts and utilities
local cyclefocus = require("cyclefocus")       -- Cycle between applications
local freedesktop = require("freedesktop")      -- Create a menu from .desktop files
local treetile = require("treetile")           -- Hierarchical window arrangement
-- CLOCK WIDGET
-- Restore previous clock style: Hack font, white on purple, with right margin
local mytextclock = wibox.widget.textclock()
mytextclock.format = "%a %b %d  %H:%M"
mytextclock.font = "Hack Nerd Font 9"
local textclock_clr = wibox.widget.background()
-- add at least 4px of purple padding on both sides
textclock_clr:set_widget(wibox.container.margin(mytextclock, 4, 4, 0, 0))
textclock_clr:set_fg("#ffffff")
textclock_clr:set_bg("#623997")

-- Enable hotkeys help widget for VIM and other apps
-- when client with a matching name is opened:
-- require("awful.hotkeys_popup.keys")


-- // MARK: VARS
-- ################################################################################
-- ██╗   ██╗ █████╗ ██████╗ ███████╗
-- ██║   ██║██╔══██╗██╔══██╗██╔════╝
-- ██║   ██║███████║██████╔╝███████╗
-- ╚██╗ ██╔╝██╔══██║██╔══██╗╚════██║
--  ╚████╔╝ ██║  ██║██║  ██║███████║
--   ╚═══╝  ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝
-- ################################################################################
-- VARIABLES - global variables and configuration constants
-- ################################################################################
-- Store the previous tag when switching to pavucontrol
local previous_tag = nil

-- Utility functions
-- Matcher generator for rules
local create_matcher = function(class_name)
    return function(c) return awful.rules.match(c, {class = class_name}) end
end

-- Confirmation menu for quitting awesome
confirmQuitmenu = awful.menu({
    items = {
        {"Cancel", function() do end end},
        {"Quit", function() awesome.quit() end}
    }
})

-- Tag navigation modifier keys
tag_nav_mod_keys = {modkey, altkey}

-- Default layout for milk theme
milkdefault = lain.layout.termfair.center

-- Tyrannical tag configuration (commented out but kept for reference)
-- tyrannical.tags = {
--   {
--     name        = "1 Term",                 -- Call the tag "Term"
--     init        = true,                   -- Load the tag on startup
--     exclusive   = true,                   -- Refuse any other type of clients (by classes)
--     screen      = {1,2},                  -- Create this tag on screen 1 and screen 3
--     layout      = milkdefault,
--     instance    = {"dev", "ops"},         -- Accept the following instances. This takes precedence over 'class'
--     class       = { --Accept the following classes, refuse everything else (because of "exclusive=true")
--       "xterm" , "urxvt" , "aterm","URxvt","XTerm","konsole","terminator","gnome-terminal","alacritty"
--     }
--   } ,
--   {
--     name        = "2 Music",
--     init        = true,
--     exclusive   = true,
--     screen      = 1,
--     layout      = awful.layout.suit.max                          ,
--     single_instance_id = { "ncmpcpp" },
--     class = {
--     "*" },
--   } ,
--   {
--     name        = "3 Media",
--     init        = true,
--     exclusive   = true,
--     screen      = 1,
--     layout      = awful.layout.suit.max                          ,
--     class = {
--     "mpv" },
--   } ,
--   {
--     name        = "4 Share",
--     init        = true,
--     exclusive   = true,
--     screen      = 1,
--     layout      = awful.layout.suit.max                          ,
--     class ={
--     "qBittorrent", "Nicotine" }
--   } ,
--   {
--     name        = "5 Other",
--     init        = true,
--     exclusive   = true,
--     screen      = 1,
--     layout      = awful.layout.suit.max                          ,
--     class ={
--     "" }
--   } ,
--   {
--     name        = "6 Files",
--     init        = true,
--     exclusive   = true,
--     screen      = 1,
--     layout      = awful.layout.suit.tile,
--     -- exec_once   = {"doublecmd"}, --When the tag is accessed for the first time, execute this command
--     class  = {
--       "Thunar", "Konqueror", "Dolphin", "ark", "Nautilus","emelfm", "Doublecmd"
--     }
--   } ,
--   {
--     name        = "7 Stuff",
--     init        = true,
--     exclusive   = true,
--     screen      = 1,
--     layout      = awful.layout.suit.max                          ,
--     class ={
--     "" }
--   } ,
--           {
--     name        = "8 Pass",
--     init        = true,
--     exclusive   = true,
--     screen      = 1,
--     layout      = awful.layout.suit.max                          ,
--     class ={
--     "keepassxc" }
--   } ,
--   {
--     name        = "9 Vol",
--     init        = true,
--     exclusive   = true,
--     screen      = 1,
--     layout      = awful.layout.suit.max                          ,
--     class = {
--     "Pavucontrol", "Jack_mixer" }
--   } ,
--   {
--     name        = "0 Sys",
--     init        = true,
--     exclusive   = true,
--     screen      = 1,
--     layout      = awful.layout.suit.max                          ,
--     class ={
--     "" }
--   } ,
--   {
--     name        = "- Chat",
--     init        = true,
--     exclusive   = true,
--     screen      = 1,
--     layout      = awful.layout.suit.max                          ,
--     class ={
--     "quassel" }
--   } ,
--   {
--     name        = "= Web",
--     init        = true,
--     exclusive   = true,
--     -- icon        = "~net.png",                 -- Use this icon for the tag (uncomment with a real path)
--     -- screen      = screen.count()>1 and 2 or 1,-- Setup on screen 2 if there is more than 1 screen, else on screen 1
--     screen      = 1,
--     layout      = awful.layout.suit.max,      -- Use the max layout
--     class = {
--       "Opera"         , "Firefox"        , "Rekonq"    , "Dillo"        , "Arora",
--     "Chromium"      , "nightly"        , "minefield" , "Firefox-esr"     }
--   } ,
--   }
--
--
--
-- -- Ignore the tag "exclusive" property for the following clients (matched by classes)
-- tyrannical.properties.intrusive = {
--   "ksnapshot"     , "pinentry"       , "gtksu"     , "kcalc"        , "xcalc"               ,
--   "feh"           , "Gradient editor", "About KDE" , "Paste Special", "Background color"    ,
--   "kcolorchooser" , "plasmoidviewer" , "Xephyr"    , "kruler"       , "plasmaengineexplorer",
-- }
--
-- -- Ignore the tiled layout for the matching clients
-- tyrannical.properties.floating = {
--   "MPlayer"      , "pinentry"        , "ksnapshot"  , "pinentry"     , "gtksu"          ,
--   "xine"         , "feh"             , "kmix"       , "kcalc"        , "xcalc"          ,
--   "yakuake"      , "Select Color$"   , "kruler"     , "kcolorchooser", "Paste Special"  ,
--   "New Form"     , "Insert Picture"  , "kcharselect", "mythfrontend" , "plasmoidviewer"
-- }
--
-- -- Make the matching clients (by classes) on top of the default layout
-- tyrannical.properties.ontop = {
--   "Xephyr"       , "ksnapshot"       , "kruler"
-- }
--
-- -- Force the matching clients (by classes) to be centered on the screen on init
-- tyrannical.properties.placement = {
--   kcalc = awful.placement.centered
-- }
--
-- tyrannical.settings.block_children_focus_stealing = true --Block popups ()
-- tyrannical.settings.group_children = true --Force popups/dialogs to have the same tags as the parent client

-- Screen rotation function
function rotate_screens(direction)
    local current_screen = awful.screen.focused()
    local initial_scren = current_screen
    while (true) do
        awful.screen.focus_relative(direction)
        local next_screen = awful.screen.focused()
        if next_screen == initial_scren then
            return
        end

        local current_screen_tag_name = current_screen.selected_tag.name
        local next_screen_tag_name = next_screen.selected_tag.name

        for _, t in ipairs(current_screen.tags) do
            local fallback_tag = awful.tag.find_by_name(next_screen, t.name)
            local self_clients = t:clients()
            local other_clients

            if not fallback_tag then
                -- if not available, use first tag
                fallback_tag = next_screen.tags[1]
                other_clients = {}
            else
                other_clients = fallback_tag:clients()
            end

            for _, c in ipairs(self_clients) do
                c:move_to_tag(fallback_tag)
            end

            for _, c in ipairs(other_clients) do
                c:move_to_tag(t)
            end
        end
        awful.tag.find_by_name(next_screen, current_screen_tag_name):view_only()
        awful.tag.find_by_name(current_screen, next_screen_tag_name):view_only()
        current_screen = next_screen
    end
end

-- Tag navigation functions
local function move_to_previous_tag()
    local c = client.focus
    if not c then return end
    local current_tag = c:tags()[1]
    if not current_tag then return end
    local prev_tag = awful.tag.getprev(current_tag)
    if prev_tag then
        c:move_to_tag(prev_tag)
    end
end

local function move_to_next_tag()
    local c = client.focus
    if not c then return end
    local current_tag = c:tags()[1]
    if not current_tag then return end
    local next_tag = awful.tag.getnext(current_tag)
    if next_tag then
        c:move_to_tag(next_tag)
    end
end

-- Function to cycle through tags with clients (including minimized ones)
local function cycle_tags_with_clients(direction)
    local current_screen = awful.screen.focused()
    local all_tags = current_screen.tags

    -- Get the current tag index
    local current_tag = current_screen.selected_tag
    local current_index = gears.table.hasitem(all_tags, current_tag)

    -- Cycle through tags, wrap around when reaching the end/start
    for i = 1, #all_tags do
        local idx
        if direction == "next" then
            idx = (current_index + i - 1) % #all_tags + 1
        else
            idx = (current_index - i - 1) % #all_tags + 1
        end
        local tag = all_tags[idx]

        -- Check if the tag has clients (including minimized ones)
        if #tag:clients() > 0 then
            tag:view_only()
            return
        end
    end
end


-- // MARK: ERRORS
-- ################################################################################
-- ███████╗██████╗ ██████╗  ██████╗ ██████╗ ███████╗
-- ██╔════╝██╔══██╗██╔══██╗██╔═══██╗██╔══██╗██╔════╝
-- █████╗  ██████╔╝██████╔╝██║   ██║██████╔╝███████╗
-- ██╔══╝  ██╔══██╗██╔══██╗██║   ██║██╔══██╗╚════██║
-- ███████╗██║  ██║██║  ██║╚██████╔╝██║  ██║███████║
-- ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝╚══════╝
-- ################################################################################
-- ERROR HANDLING - startup and runtime error management
-- Check if awesome encountered an error during startup and fell back to another config
-- (This code will only ever execute for the fallback config)
if awesome.startup_errors then
	naughty.notify({
		preset = naughty.config.presets.critical,
		title = "Oops, there were errors during startup!",
		text = awesome.startup_errors
	})
end

-- Handle runtime errors after startup
do
	local in_error = false
	awesome.connect_signal("debug::error", function(err)
		-- Make sure we don't go into an endless error loop
		if in_error then return end
		in_error = true

		naughty.notify({
			preset = naughty.config.presets.critical,
			title = "Oops, an error happened!",
			text = tostring(err)
		})
		in_error = false
	end)
end


-- // MARK: DEFS
-- ################################################################################
-- ██████╗ ███████╗███████╗███████╗
-- ██╔══██╗██╔════╝██╔════╝██╔════╝
-- ██║  ██║█████╗  █████╗  ███████╗
-- ██║  ██║██╔══╝  ██╔══╝  ╚════██║
-- ██████╔╝███████╗██║     ███████║
-- ╚═════╝ ╚══════╝╚═╝     ╚══════╝
-- ################################################################################
-- DEFINITIONS - theme configuration and visual foundations
beautiful.init(gears.filesystem.get_configuration_dir() .. "milktheme/theme.lua")

-- Theme customization - force purple background for selected tags
beautiful.taglist_bg_focus = "#663399" -- purple for selected tag (matches standard purple)
beautiful.taglist_hover_bg = "#b8860b" -- gold hover for non-drag hover
-- Keep tag text white for now
-- beautiful.taglist_fg_normal and beautiful.taglist_fg_focus left to theme defaults (white)
-- Ensure title/task text never renders black-on-black
beautiful.titlebar_fg_focus = "#FFD700"
beautiful.titlebar_fg_normal = "#FFFFFF"
beautiful.tasklist_fg_focus = beautiful.tasklist_fg_focus or "#FFD700"
beautiful.tasklist_fg_normal = beautiful.tasklist_fg_normal or "#FFFFFF"

-- create dynamic square surfaces for occupancy indication
local cairo = require("lgi").cairo

-- Function to create a square surface
local TAG_SQUARE_SIZE = 5

local function create_square_surface(filled, size)
    size = size or TAG_SQUARE_SIZE
    local img = cairo.ImageSurface(cairo.Format.ARGB32, size, size)
    local cr = cairo.Context(img)
    
    if filled then
        -- Filled square for unminimized windows
        cr:set_source_rgba(0.7, 0.7, 0.7, 1) -- light gray
        cr:rectangle(0, 0, size, size)  -- Fill entire surface
        cr:fill()
    else
        -- Hollow square for minimized-only windows
        cr:set_source_rgba(0.5, 0.5, 0.5, 1) -- darker gray
        cr:set_line_width(0.5)
        cr:rectangle(0.25, 0.25, size-0.5, size-0.5)  -- Adjusted for smaller size
        cr:stroke()
    end
    
    return img
end

-- Create square surfaces for different states
local filled_square = create_square_surface(true, TAG_SQUARE_SIZE)
local hollow_square = create_square_surface(false, TAG_SQUARE_SIZE)

-- Colored square cache and helpers for dominant icon colors
local square_surface_cache = {}

local function hex_to_rgb(hex)
    if not hex or #hex < 7 then return 170,170,170 end
    local r = tonumber(hex:sub(2,3), 16) or 170
    local g = tonumber(hex:sub(4,5), 16) or 170
    local b = tonumber(hex:sub(6,7), 16) or 170
    return r,g,b
end

local function create_colored_square_surface(filled, size, color_hex)
    local key = (filled and "F" or "H") .. ":" .. (color_hex or "#aaaaaa") .. ":" .. tostring(size)
    if square_surface_cache[key] then return square_surface_cache[key] end
    
    local img = cairo.ImageSurface(cairo.Format.ARGB32, size, size)
    local cr = cairo.Context(img)
    local r,g,b = hex_to_rgb(color_hex)
    r, g, b = r/255, g/255, b/255
    
    if filled then
        cr:set_source_rgba(r, g, b, 1)
        cr:rectangle(0, 0, size, size)
        cr:fill()
    else
        cr:set_source_rgba(r, g, b, 1)
        cr:set_line_width(0.5)
        cr:rectangle(0.25, 0.25, size-0.5, size-0.5)
        cr:stroke()
    end
    
    square_surface_cache[key] = img
    return img
end

-- Sample dominant color from client icon
local function average_color_from_icon(icon)
    if not icon then return "#aaaaaa" end
    
    local ok, surf = pcall(gears.surface, icon)
    if not ok or not surf then return "#aaaaaa" end
    
    -- Get icon dimensions
    local w, h = 32, 32
    local okw, valw = pcall(function() return surf:get_width() end)
    if okw and type(valw) == 'number' and valw > 0 then w = valw end
    local okh, valh = pcall(function() return surf:get_height() end)
    if okh and type(valh) == 'number' and valh > 0 then h = valh end
    if w <= 0 or h <= 0 then return "#aaaaaa" end
    
    -- Create 1x1 downscale to get average color
    local img = cairo.ImageSurface(cairo.Format.ARGB32, 1, 1)
    local cr = cairo.Context(img)
    cr:scale(1/w, 1/h)
    cr:set_source_surface(surf, 0, 0)
    cr:paint()
    
    -- Extract pixel data
    local data = nil
    local okd, val = pcall(function() return img:get_data() end)
    if okd then data = val end
    if not data or #data < 4 then return "#aaaaaa" end
    
    -- Cairo uses BGRA format
    local b = string.byte(data, 1)
    local g = string.byte(data, 2)
    local r = string.byte(data, 3)
    local a = string.byte(data, 4)
    
    -- Handle premultiplied alpha
    if a and a > 0 and a < 255 then
        local inv = 255 / a
        r = math.min(255, math.floor(r * inv))
        g = math.min(255, math.floor(g * inv))
        b = math.min(255, math.floor(b * inv))
    end
    
    return string.format("#%02x%02x%02x", r, g, b)
end

-- Create a simple generic terminal icon surface (fallback when no file icon is available)
local function create_terminal_icon_surface(size)
    size = size or 16
    local img = cairo.ImageSurface(cairo.Format.ARGB32, size, size)
    local cr = cairo.Context(img)

    -- Clear (transparent)
    cr:set_source_rgba(0, 0, 0, 0)
    cr:paint()

    -- Terminal screen rectangle
    local pad = math.max(1, math.floor(size * 0.12))
    local w = size - pad * 2
    local h = size - pad * 2
    cr:set_line_width(math.max(1, size * 0.08))
    cr:set_source_rgba(1, 1, 1, 1) -- white outline
    cr:rectangle(pad, pad, w, h)
    cr:stroke()

    -- Prompt glyph (>_)
    cr:set_line_width(math.max(1, size * 0.12))
    local gx = pad + math.floor(size * 0.18)
    local gy = pad + math.floor(size * 0.48)
    cr:move_to(gx, gy)
    cr:line_to(gx + math.floor(size * 0.22), gy - math.floor(size * 0.14))
    cr:move_to(gx, gy)
    cr:line_to(gx + math.floor(size * 0.22), gy + math.floor(size * 0.14))
    cr:stroke()

    -- Cursor underscore
    cr:set_line_width(math.max(1, size * 0.10))
    cr:move_to(gx + math.floor(size * 0.32), gy + math.floor(size * 0.18))
    cr:line_to(gx + math.floor(size * 0.54), gy + math.floor(size * 0.18))
    cr:stroke()

    return img
end

-- Get dominant color for a tag based on visible client icons
local function get_tag_dominant_color(tag)
    if not tag or not tag.valid then return "#aaaaaa" end
    
    local rs, gs, bs, n = 0, 0, 0, 0
    local clients = tag:clients()
    if #clients == 0 then return "#aaaaaa" end
    
    -- First pass: only visible (unminimized, unhidden) clients
    for _, c in ipairs(clients) do
        if c.icon and (not c.minimized and not c.hidden) then
            local hex = average_color_from_icon(c.icon)
            local r,g,b = hex_to_rgb(hex)
            rs, gs, bs = rs + r, gs + g, bs + b
            n = n + 1
        end
    end
    
    -- Fallback: any client with icon
    if n == 0 then
        for _, c in ipairs(clients) do
            if c.icon then
                local hex = average_color_from_icon(c.icon)
                local r,g,b = hex_to_rgb(hex)
                rs, gs, bs = rs + r, gs + g, bs + b
                n = n + 1
            end
        end
    end
    
    if n == 0 then return "#aaaaaa" end
    
    local r = math.floor(rs / n)
    local g = math.floor(gs / n)
    local b = math.floor(bs / n)
    return string.format("#%02x%02x%02x", r, g, b)
end

-- Override taglist square surfaces with dynamic occupancy-based squares
local function update_tag_squares()
    -- disable built-in taglist squares; we'll draw our own in widget_template
    beautiful.taglist_squares_sel = nil
    beautiful.taglist_squares_unsel = nil
    beautiful.taglist_squares_sel_empty = nil
    beautiful.taglist_squares_unsel_empty = nil
    beautiful.taglist_squares_resize = false
end

-- Initialize squares
update_tag_squares()

-- Override the taglist's square selection logic
local original_taglist_squares_sel = beautiful.taglist_squares_sel
local original_taglist_squares_unsel = beautiful.taglist_squares_unsel

-- Create a function to get the right square based on tag state
local function get_tag_square(tag, is_selected)
    local state = get_tag_square_state(tag)
    if state == "visible" then
        return filled_square  -- filled square for visible windows (what you'd see on tag switch)
    else
        return hollow_square  -- hollow square for no visible windows (empty, minimized, or hidden)
    end
end

-- Override the taglist square selection logic to use occupancy-based squares
local original_taglist_update_function = nil

local function get_tag_square_state(tag)
    local clients = tag:clients()
    if #clients == 0 then
        return "empty"        -- no clients at all
    end
    for _, c in ipairs(clients) do
        -- visible when not minimized and not hidden
        if not c.minimized and not c.hidden then
            return "visible"
        end
    end
    return "no_visible"       -- clients exist but none would be visible
end

-- Hook into tag client changes to update squares dynamically
local function setup_dynamic_squares()
    -- Store references to the original square surfaces
    local original_squares_sel = beautiful.taglist_squares_sel
    local original_squares_unsel = beautiful.taglist_squares_unsel
    
    -- Create our custom squares
    local filled_square = create_square_surface(true)
    local hollow_square = create_square_surface(false)
    
    -- Override the beautiful theme to dynamically return squares based on tag state
    local taglist_squares_sel_orig = beautiful.taglist_squares_sel
    local taglist_squares_unsel_orig = beautiful.taglist_squares_unsel
    
    -- Connect to tag client changes
    tag.connect_signal("property::clients", function(t)
        -- Force taglist update for this tag's screen
        if t.screen and t.screen.mytaglist then
            t.screen.mytaglist:emit_signal("widget::redraw_needed")
        end
    end)
    
    -- Connect to client minimize/unminimize
    client.connect_signal("property::minimized", function(c)
        if c and c.valid and c.tags then
            for _, t in ipairs(c:tags()) do
                if t.screen and t.screen.mytaglist then
                    t.screen.mytaglist:emit_signal("widget::redraw_needed")
                end
            end
        end
    end)
    
    -- Connect to tag selection changes
    tag.connect_signal("property::selected", function(t)
        if t.screen and t.screen.mytaglist then
            t.screen.mytaglist:emit_signal("widget::redraw_needed")
        end
    end)
end

-- We'll call this after screen setup
local setup_squares_called = false
beautiful.wallpaper = awful.util.get_configuration_dir() .. "milktheme/background.png"

-- Font settings
beautiful.hotkeys_font = "Hack Nerd Font 12"
-- beautiful.hotkeys_description_font = "JetBrains Mono 12"
-- beautiful.menu_font = "JetBrains Mono 14"
-- beautiful.menu_font = "Hack 14"  -- Now set in theme file
beautiful.menu_height = 24
beautiful.menu_width = 300

-- Color settings
beautiful.bg_systray = "#000000"
-- beautiful.bg_systray = "#191919"
beautiful.notification_bg = "#FFD700"  -- Gold background
beautiful.notification_fg = "#000000"  -- Black text
beautiful.hotkeys_modifiers_fg = "#dddddd"

-- Notification settings
naughty.config.defaults.ontop = true
-- naughty.config.defaults.timeout = 10
-- naughty.config.defaults.margin = dpi("16")
-- naughty.config.defaults.border_width = 0
naughty.config.defaults.width = 400  -- Width in pixels instead of percentage string
naughty.config.defaults.position = 'bottom_middle'

-- Notification icon settings
-- Attempt to constrain the size of large icons in their apps notifications
beautiful.notification_icon_size = 64  -- Number instead of string
naughty.config.defaults['icon_size'] = 64


-- // MARK: MODIFIERS
-- ################################################################################
-- ███╗   ███╗ ██████╗ ██████╗ ██╗███████╗██╗███████╗███████╗██████╗ ███████╗
-- ████╗ ████║██╔═══██╗██╔══██╗██║██╔════╝██║██╔════╝██╔════╝██╔══██╗██╔════╝
-- ██╔████╔██║██║   ██║██║  ██║██║███████╗██║███████╗███████╗██████╔╝███████╗
-- ██║╚██╔╝██║██║   ██║██║  ██║██║╚════██║██║╚════██║╚════██║██╔══██╗╚════██║
-- ██║ ╚═╝ ██║╚██████╔╝██████╔╝██║███████║██║███████║███████║██║  ██║███████║
-- ╚═╝     ╚═╝ ╚═════╝ ╚═════╝ ╚═╝╚══════╝╚═╝╚══════╝╚══════╝╚═╝  ╚═╝╚══════╝
-- ################################################################################
-- MODIFIERS - modifier key definitions and constants
-- Default modkey (Mod4 is usually the key with a logo between Control and Alt)
-- To remap, use xmodmap or other tools
modkey = "Mod4"
altkey = "Mod1"    -- Alt key
ctrlkey = "Control" -- Control key
shiftkey = "Shift"  -- Shift key


-- // MARK: HOTKEYS
-- ################################################################################
-- ██╗  ██╗ ██████╗ ████████╗██╗  ██╗███████╗██╗   ██╗███████╗
-- ██║  ██║██╔═══██╗╚══██╔══╝██║ ██╔╝██╔════╝╚██╗ ██╔╝██╔════╝
-- ███████║██║   ██║   ██║   █████╔╝ █████╗   ╚████╔╝ ███████╗
-- ██╔══██║██║   ██║   ██║   ██╔═██╗ ██╔══╝    ╚██╔╝  ╚════██║
-- ██║  ██║╚██████╔╝   ██║   ██║  ██╗███████╗   ██║   ███████║
-- ╚═╝  ╚═╝ ╚═════╝    ╚═╝   ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚══════╝
-- ################################################################################
-- HOTKEYS - global and client key bindings

-- global key bindings
globalkeys = gears.table.join(
    awful.key({ modkey,           }, "s",      hotkeys_popup.show_help,
              {description="show help", group="awesome"}),
    awful.key({ modkey,           }, "Left",   function() cycle_tags_with_clients("prev") end,
              {description = "cycle to previous tag with clients", group = "tag"}),
    awful.key({ modkey,           }, "Right",  function() cycle_tags_with_clients("next") end,
              {description = "cycle to next tag with clients", group = "tag"}),
    awful.key({ modkey, shiftkey, ctrlkey }, "Left",   awful.tag.viewprev,
              {description = "view previous", group = "tag"}),
    awful.key({ modkey, shiftkey, ctrlkey }, "Right",  awful.tag.viewnext,
              {description = "view next", group = "tag"}),
    awful.key({ modkey,           }, "Escape", awful.tag.history.restore,
              {description = "go back", group = "tag"}),

    awful.key({ modkey,           }, "j",
        function ()
            awful.client.focus.byidx( 1)
        end,
        {description = "focus next by index", group = "client"}
    ),
    awful.key({ modkey,           }, "k",
        function ()
            awful.client.focus.byidx(-1)
        end,
        {description = "focus previous by index", group = "client"}
    ),
    awful.key({ modkey,           }, "w", function () 
        if client.focus then
            client.focus:kill()
        end
    end,
              {description = "close window", group = "client"}),

    -- Layout manipulation
        awful.key({ modkey, shiftkey   }, "j", function () awful.client.swap.byidx(  1)    end,
        {description = "swap with next client by index", group = "client"}),
    awful.key({ modkey, shiftkey   }, "k", function () awful.client.swap.byidx( -1)    end,
		{description = "swap with previous client by index", group = "client"}),
        awful.key({ modkey, ctrlkey }, "j", function () awful.screen.focus_relative( 1) end,
        {description = "focus the next screen", group = "screen"}),
    awful.key({ modkey, ctrlkey }, "k", function () awful.screen.focus_relative(-1) end,
	{description = "focus the previous screen", group = "screen"}),
    awful.key({ modkey,           }, "u", awful.client.urgent.jumpto,
              {description = "jump to urgent client", group = "client"}),
    awful.key({ modkey,           }, "Tab",
        function ()
            awful.client.focus.history.previous()
            if client.focus then
                client.focus:raise()
            end
        end,
        {description = "go back", group = "client"}),

-- Standard program
    awful.key({ modkey,           }, "Return", function () awful.spawn(terminal) end,
              {description = "open a terminal", group = "launcher"}),
    awful.key({ modkey, ctrlkey }, "r", awesome.restart,
              {description = "reload awesome", group = "awesome"}),
    awful.key({ modkey, shiftkey   }, "q", awesome.quit,
              {description = "quit awesome", group = "awesome"}),

    awful.key({ modkey,           }, "l",     function () awful.tag.incmwfact( 0.05)          end,
              {description = "increase master width factor", group = "layout"}),
    awful.key({ modkey,           }, "h",     function () awful.tag.incmwfact(-0.05)          end,
              {description = "decrease master width factor", group = "layout"}),
        awful.key({ modkey, shiftkey   }, "h",     function () awful.tag.incnmaster( 1, nil, true) end,
        {description = "increase the number of master clients", group = "layout"}),
    awful.key({ modkey, shiftkey   }, "l",     function () awful.tag.incnmaster(-1, nil, true) end,
              {description = "decrease the number of master clients", group = "layout"}),
        awful.key({ modkey, ctrlkey }, "h",     function () awful.tag.incncol( 1, nil, true)    end,
        {description = "increase the number of columns", group = "layout"}),
    awful.key({ modkey, ctrlkey }, "l",     function () awful.tag.incncol(-1, nil, true)    end,
              {description = "decrease the number of columns", group = "layout"}),
    awful.key({ modkey,           }, "space", function () awful.layout.inc( 1)                end,
              {description = "select next", group = "layout"}),
    awful.key({ modkey, shiftkey   }, "space", function () awful.layout.inc(-1)                end,
              {description = "select previous", group = "layout"}),

    awful.key({ modkey, ctrlkey }, "n",
              function ()
                  local c = awful.client.restore()
                  -- Focus restored client
                  if c then
                    c:emit_signal(
                        "request::activate", "key.unminimize", {raise = true}
                    )
                  end
              end,
              {description = "restore minimized", group = "client"}),

    -- Prompt (like rofi menu but different)
    awful.key({ modkey, altkey },            "r",     function () awful.screen.focused().mypromptbox:run() end,
              {description = "run prompt", group = "launcher"}),

    awful.key({ modkey }, "x",
              function ()
	awful.prompt.run {
                    prompt       = "Run Lua code: ",
                    textbox      = awful.screen.focused().mypromptbox.widget,
		exe_callback = awful.util.eval,
		history_path = awful.util.get_cache_dir() .. "/history_eval"
	}
              end,
              {description = "lua execute prompt", group = "awesome"}),
    -- Menubar
    awful.key({ modkey }, "p", function() menubar.show() end,
              {description = "show the menubar", group = "launcher"}),

    -- System controls
        -- Screen blanking (duplicate removed - using the one above),
    awful.key({modkey, altkey}, "r", function() os.execute("monitor_rofi.sh") end,
              {description = "monitor rofi", group = "system"}),
    awful.key({modkey, altkey}, "p", function() os.execute("rofi_power") end,
              {description = "rofi power menu", group = "system"}),

    -- Terminal variants
    awful.key({modkey, shiftkey}, "Return", function() awful.spawn(terminal, {floating = true, placement = awful.placement.centered}) end,
              {description = "open a floating terminal", group = "launcher"}),
    awful.key({ modkey, ctrlkey }, "Return", function () awful.util.spawn("sh -c 'alacritty --working-directory \"$(lastcwd)\"'") end,
              {description = "open a terminal in same directory", group = "launcher"}),
    awful.key({ modkey, altkey }, "Return", function () awful.util.spawn("urxvt") end,
              {description = "open urxvt terminal", group = "launcher"}),

    -- Layout control (using shiftkey instead of altkey to avoid conflict with prompt)
    awful.key({modkey, shiftkey}, "r", function() awful.layout.inc(-1) end,
              {description = "select previous layout", group = "layout"}),

    -- Client management
    awful.key({modkey}, "0", function() awful.tag.viewidx(10) end,
              {description = "view tag #10", group = "tag"}),

    -- Restore all minimized windows
    awful.key({modkey, altkey}, ";", function()
        for _, c in ipairs(client.get()) do
            if c.minimized then
                c:activate{
                    raise = true
                }
                c.minimized = false
            end
        end
    end, {description = "restore all minimized windows", group = "client"}),

    -- Cycle through minimized windows
    awful.key({modkey}, ";", function()
        if client.focus then
            local c = client.focus
            local nxt = nil
            for x in awful.client.iterate(function(x)
                return x.minimized
            end) do
                if nxt then
                    nxt:swap(x)
                else
                    nxt = x
                end
            end
            c.minimized = true
            nxt.minimized = false
            c:swap(nxt)
            client.focus = nxt
            nxt:raise()
        end
    end,
    {description = "cycle minimized windows", group = "client"}),

    -- Toggle floating window to the corner
    awful.key({modkey, shiftkey}, "w", function()
        local c = client.focus
        awful.client.floating.toggle()
        if c.floating then
            c.floating = false
            c.ontop = false
            c.sticky = false
        else
            c.floating = true
            c.ontop = true
            c.sticky = true
            c.width = 633
            c.height = 400
            awful.placement.top_right(client.focus)
        end
    end, {description = "ontop floating right corner", group = "client"}),

    -- Edit awesome config
    awful.key({modkey, shiftkey}, "e", function() awful.spawn.raise_or_spawn("urxvt -e sh -c '$EDITOR ~/.config/awesome/rc.lua'", nil, nil, "awesomeconf")
    end, {description = "edit awesome config", group = "launcher"}),

    -- Hue lighting sync
    awful.key({modkey, ctrlkey, altkey}, "h", function () awful.util.spawn("huestacean") end,
              {description = "open huestacean", group = "launcher"}),

    -- Application launchers
    awful.key({modkey}, "F12", function() awful.spawn.raise_or_spawn("firefox", nil, create_matcher("firefox"))
    end, {description = "run firefox", group = "launcher"}),

    awful.key({modkey, shiftkey}, "F12", function() awful.spawn.raise_or_spawn("chromium", nil, create_matcher("chromium"))
    end, {description = "run chromium", group = "launcher"}),

    awful.key({modkey}, "p", function() awful.spawn.raise_or_spawn("pavucontrol", nil, create_matcher("pavucontrol"))
    end, {description = "run pavucontrol", group = "launcher"}),

    awful.key({modkey}, "Print", function() awful.spawn.with_shell("flameshot gui", false)
    end, {description = "take a screenshot with flameshot", group = "launcher"}),

    awful.key({modkey, altkey}, "q", function() awful.spawn.with_shell("xkill", false)
    end, {description = "xkill to kill a hung gui app", group = "launcher"}),

    awful.key({modkey, altkey}, "c", function() awful.spawn.with_shell("xcolor -s clipboard", false)
    end, {description = "colour picker to clipboard", group = "launcher"}),

    awful.key({ modkey, ctrlkey }, "a", function() awful.spawn.with_shell("arandr", false) end,
    {description = "run arandr", group = "launcher"}),

    -- F-key application launchers
    awful.key({modkey}, "F1", function() awful.spawn.raise_or_spawn("urxvt -e sh -c 'ncmpcpp' -name 'ncmpcpp'", nil, nil, "ncmpcpp")
    end, {description = "run ncmpcpp in a terminal", group = "launcher"}),

    awful.key({modkey, shiftkey}, "F1", function() awful.spawn.raise_or_spawn("spotify", nil, create_matcher("spotify"), "spotify")
    end, {description = "run spotify", group = "launcher"}),

    awful.key({modkey}, "F2", function() awful.spawn.raise_or_spawn("raysession", nil, create_matcher("raysession"))
    end, {description = "run raysession", group = "launcher"}),

    awful.key({modkey, shiftkey}, "F2", function() awful.spawn.raise_or_spawn("urxvt -e sh -c 'nsm'", nil, create_matcher("nsm"), "nsm")
    end, {description = "run argodejo in a terminal", group = "launcher"}),

    awful.key({modkey}, "F3", function() awful.spawn.raise_or_spawn("qbittorrent", nil, create_matcher("qBittorrent"), "qBittorrent")
    end, {description = "run qbittorrent", group = "launcher"}),

    awful.key({modkey, shiftkey}, "F3", function() awful.spawn.raise_or_spawn("nicotine", nil, create_matcher("Nicotine"))
    end, {description = "run nicotine++", group = "launcher"}),

    awful.key({modkey}, "F4", function() awful.spawn.raise_or_spawn("picard", nil, create_matcher("Picard"))
    end, {description = "run picard", group = "launcher"}),

    awful.key({modkey, shiftkey}, "F4", function() awful.spawn.raise_or_spawn("simplescreenrecorder", nil, create_matcher("simplescreenrecorder"))
    end, {description = "run simplescreenrecorder", group = "launcher"}),

    awful.key({modkey, shiftkey}, "F6", function() awful.spawn.raise_or_spawn("qseq66", nil, create_matcher("qseq66"))
    end, {description = "run qseq66", group = "launcher"}),

    awful.key({modkey, shiftkey}, "F7", function() awful.spawn.raise_or_spawn("signal-desktop", nil, create_matcher("signal-desktop"))
    end, {description = "run signal-desktop", group = "launcher"}),

    awful.key({modkey}, "F8", function() awful.spawn.raise_or_spawn("keepassxc ~/state/nextcloud/sync/keepassxc-mb.kdbx", nil, create_matcher("keepassxc"))
    end, {description = "run keepassxc", group = "launcher"}),

    awful.key({modkey}, "F9", function() awful.spawn.raise_or_spawn("doublecmd", nil, create_matcher("doublecmd"))
    end, {description = "run doublecmd", group = "launcher"}),

    awful.key({ modkey }, "F11", function() awful.spawn.raise_or_spawn("quasselclient", nil, nil, "quasselclient") end,
    { description = "run quasselclient", group = "launcher" })
)

-- Bind all key numbers to tags.
-- Be careful: we use keycodes to make it work on any keyboard layout.
-- This should map on the top row of your keyboard, usually 1 to 9.
for i = 1, 9 do
    globalkeys = gears.table.join(globalkeys,
        -- View tag only.
        awful.key({ modkey }, "#" .. i + 9,
                  function ()
                        local screen = awful.screen.focused()
                        local tag = screen.tags[i]
                        if tag then
                           tag:view_only()
                        end
                  end,
                  {description = "view tag #"..i, group = "tag"}),
        -- Toggle tag display.
        awful.key({ modkey, ctrlkey }, "#" .. i + 9,
                  function ()
                      local screen = awful.screen.focused()
                      local tag = screen.tags[i]
                      if tag then
                         awful.tag.viewtoggle(tag)
                      end
                  end,
                  {description = "toggle tag #" .. i, group = "tag"}),
        -- Move client to tag.
        awful.key({ modkey, shiftkey }, "#" .. i + 9,
                  function ()
                      if client.focus then
                          local tag = client.focus.screen.tags[i]
                          if tag then
                              client.focus:move_to_tag(tag)
                          end
                     end
                  end,
                  {description = "move focused client to tag #"..i, group = "tag"}),
        -- Toggle tag on focused client.
        awful.key({ modkey, ctrlkey, shiftkey }, "#" .. i + 9,
                  function ()
                      if client.focus then
                          local tag = client.focus.screen.tags[i]
                          if tag then
                              client.focus:toggle_tag(tag)
                          end
                      end
                  end,
                  {description = "toggle focused client on tag #" .. i, group = "tag"})
    )
end

-- client key bindings
clientkeys = gears.table.join(
    awful.key({ modkey,           }, "f",
        function (c)
		c.fullscreen = not c.fullscreen
		c:raise()
        end,
        {description = "toggle fullscreen", group = "client"}),
    awful.key({ modkey, shiftkey   }, "c",      function (c) c:kill()                         end,
		{description = "close", group = "client"}),
    awful.key({ modkey }, "z",  awful.client.floating.toggle                     ,
{description = "toggle floating", group = "client"}),
    awful.key({ modkey, ctrlkey }, "Return", function (c) c:swap(awful.client.getmaster()) end,
{description = "move to master", group = "client"}),
    awful.key({ modkey,           }, "o",      function (c) c:move_to_screen()               end,
              {description = "move to screen", group = "client"}),
    awful.key({ modkey,           }, "t",      function (c) c.ontop = not c.ontop            end,
              {description = "toggle keep on top", group = "client"}),
    awful.key({ modkey,           }, "n",
        function (c)
	-- The client currently has the input focus, so it cannot be
            -- minimized, since minimized clients can't have the focus.
	c.minimized = true
        end ,
        {description = "minimize", group = "client"}),
    awful.key({ modkey,           }, "m",
        function (c)
	c.maximized = not c.maximized
	c:raise()
        end ,
        {description = "(un)maximize", group = "client"}),
    awful.key({ modkey, ctrlkey }, "m",
        function (c)
	c.maximized_vertical = not c.maximized_vertical
	c:raise()
        end ,
        {description = "(un)maximize vertically", group = "client"}),
    awful.key({ modkey, shiftkey   }, "m",
        function (c)
	c.maximized_horizontal = not c.maximized_horizontal
	c:raise()
        end ,
        {description = "(un)maximize horizontally", group = "client"})
)

-- simple drag-to-tag functionality
-- awesome_dnd drag-and-drop system is defined in RUNTIME section


-- // MARK: TERM
-- ################################################################################
-- ████████╗███████╗██████╗ ███╗   ███╗
-- ╚══██╔══╝██╔════╝██╔══██╗████╗ ████║
--    ██║   █████╗  ██████╔╝██╔████╔██║
--    ██║   ██╔══╝  ██╔══██╗██║╚██╔╝██║
--    ██║   ███████╗██║  ██║██║ ╚═╝ ██║
--    ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝
-- ################################################################################
-- TERMINAL - terminal and editor application definitions
-- Define default terminal and editor
terminal = "urxvt"
-- terminal = "alacritty"
editor = os.getenv("EDITOR") or "nvim"
editor_cmd = terminal .. " -e " .. editor

-- Compound terminal command for system monitoring
terminal_cmd = terminal .. " -e btop;" ..
               terminal .. " -e journalctl -xeb;" ..
               terminal .. " -e dmesg"


-- // MARK: VISUAL
-- ################################################################################
-- ██╗   ██╗██╗███████╗██╗   ██╗ █████╗ ██╗     
-- ██║   ██║██║██╔════╝██║   ██║██╔══██╗██║     
-- ██║   ██║██║███████╗██║   ██║███████║██║     
-- ╚██╗ ██╔╝██║╚════██║██║   ██║██╔══██║██║     
--  ╚████╔╝ ██║███████║╚██████╔╝██║  ██║███████╗
--   ╚═══╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝  ╚═╝╚══════╝
-- ################################################################################
-- VISUAL - wallpaper, borders, and visual effects

-- WALLPAPER - Wallpaper management and configuration
-- Define wallpaper function
local function set_wallpaper(s)
	-- Wallpaper
	if beautiful.wallpaper then
		local wallpaper = beautiful.wallpaper
		-- If wallpaper is a function, call it with the screen
		if type(wallpaper) == "function" then
			wallpaper = wallpaper(s)
		end
		gears.wallpaper.maximized(wallpaper, s, true)
	end
end

-- Set wallpaper on startup
for s = 1, screen.count() do
	gears.wallpaper.maximized(beautiful.wallpaper, s, true)
end

-- Reset wallpaper when screen geometry changes
screen.connect_signal("property::geometry", set_wallpaper)

-- BORDERS - Border properties and window shapes
-- Set border properties
beautiful.border_radius = 2
beautiful.useless_gap = 0  -- window gaps (moved from end of file)

-- Handle client window shapes
client.connect_signal("manage", function(c)
    c.shape = function(cr, w, h)
        gears.shape.rounded_rect(cr, w, h, beautiful.border_radius)
    end
end)

-- Forward declaration so earlier signal handlers capture the local, not a global
local get_client_status_prefix

-- Helper function to calculate status prefix for a client
get_client_status_prefix = function(c)
    if not c or not c.valid then return "" end
    
    local symbols = {}
    if c.floating then table.insert(symbols, "✈") end
    if c.maximized then table.insert(symbols, "+")
    elseif c.maximized_horizontal then table.insert(symbols, "⬌")
    elseif c.maximized_vertical then table.insert(symbols, "⬍") end
    if c.sticky then table.insert(symbols, "▪") end
    if c.ontop then table.insert(symbols, "⌃")
    elseif c.above then table.insert(symbols, "▴")
    elseif c.below then table.insert(symbols, "▾") end
    
    -- Use a non-breaking space as separator to keep layout stable
    return #symbols > 0 and (table.concat(symbols, "") .. " ") or ""
end

-- Widget reference tables must be defined before any signal handlers use them
local active_tag_widgets = active_tag_widgets or {}
local active_client_widgets = active_client_widgets or {}

-- Update status prefix immediately for tasklist when window mode properties change
for _, prop in ipairs({
    "floating", "maximized", "maximized_horizontal", "maximized_vertical",
    "sticky", "ontop", "above", "below", "minimized"
}) do
    client.connect_signal("property::" .. prop, function(c)
        local s = c.screen
        local client_widgets = active_client_widgets[s.index] or {}
        for _, widget in pairs(client_widgets) do
            if widget.client and widget.client.valid and widget.client == c then
                local pb = widget.prefixbox
                if pb and pb.set_markup then
                    local sp = get_client_status_prefix(c)
                    pb:set_markup('<span color="#FFD700">' .. ((sp and #sp > 0) and sp or ' ') .. '</span>')
                end
                break
            end
        end
    end)
end

-- assign generic terminal icon for urxvt clients
client.connect_signal("manage", function(c)
    if c.class == "URxvt" or c.class == "urxvt" then
        local term_icon = gears.filesystem.get_configuration_dir() .. "milktheme/layouts/term.png"
        if gears.filesystem.file_readable(term_icon) then
            c.icon = term_icon
        end
    end
end)


-- // MARK: LAYOUT
-- ################################################################################
-- ██╗      █████╗ ██╗   ██╗ ██████╗ ██╗   ██╗████████╗
-- ██║     ██╔══██╗╚██╗ ██╔╝██╔═══██╗██║   ██║╚══██╔══╝
-- ██║     ███████║ ╚████╔╝ ██║   ██║██║   ██║   ██║   
-- ██║     ██╔══██║  ╚██╔╝  ██║   ██║╚██╗ ██╔╝   ██║   
-- ███████╗██║  ██║   ██║   ╚██████╔╝ ╚███╔╝    ██║   
-- ╚══════╝╚═╝  ╚═╝   ╚═╝    ╚═════╝   ╚══╝     ╚═╝   
-- ################################################################################
-- LAYOUT - layout management and navigation systems

-- NAVIGATION - Movement and collision detection
-- Navigation system using collision detection
require("collision") {
    -- Vim-style movement keys
    up    = { "k" },
    down  = { "j" },
    left  = { "h" },
    right = { "l" },

    -- Other configurations (commented out)
    -- Normal arrow keys
    -- up    = { "Up"    },
    -- down  = { "Down"  },
    -- left  = { "Left"  },
    -- right = { "Right" },

    -- Multiple key options
    -- up    = { "Up", "&", "k", "F15" },
    -- down  = { "Down", "KP_Enter", "j", "F14" },
    -- left  = { "Left", "#", "h", "F13" },
    -- right = { "Right", "\"", "l", "F17" },
}

-- Alt-Tab alternatives (disabled)
-- local switcher = require("awesome-switcher")
-- awful.key({ "Mod1" }, "Tab", function() switcher.switch(1, "Alt_L", "Tab", "ISO_Left_Tab") end)
-- awful.key({ "Mod1", "Shift" }, "Tab", function() switcher.switch(-1, "Alt_L", "Tab", "ISO_Left_Tab") end)

-- Alternative Alt-Tab implementation (disabled)
-- local alttab = require("gobo.awesome.alttab")
-- awful.key({ "Mod1" }, "Tab", function() alttab.switch(1, "Alt_L", "Tab", "ISO_Left_Tab") end,
--    { description = "Switch between windows", group = "awesome" })

-- MODULES - Additional layout and utility modules
-- Layouts, widgets and utilities

-- Custom adaptive layout
local centerwork_adaptive = require("lain.layout.centerwork_adaptive")
-- Custom two-thirds layout that gives new window 2/3 screen
local centerwork_twothirds = require("lain.layout.centerwork_twothirds")
-- Custom tile.bottom layout with enhanced mouse resize functionality
local tile_bottom_mouse = require("lain.layout.tile_bottom_mouse")

-- Disabled modules (commented out for reference)
-- local tyrannical = require("tyrannical")     -- Dynamic desktop tagging
-- require("tyrannical.shortcut")               -- Optional tyrannical shortcuts
-- local revelation = require("revelation")     -- App/desktop switching script
-- revelation.init()

-- LAYOUTS - Layout definitions and configuration
-- Active layout scripts


-- LAYOUT DEFINITIONS
-- Table of layouts to cover with awful.layout.inc, order matters.
-- https://awesomewm.org/doc/api/libraries/awful.layout.html
-- https://github.com/lcpz/lain/wiki/Layouts
awful.layout.layouts = {
    -- Active layouts in preferred order
    centerwork_twothirds.horizontal,            -- CUSTOM: Two-thirds for new window
    centerwork_adaptive.horizontal,             -- CUSTOM: Adaptive centerwork horizontal
    -- lain.layout.centerwork.horizontal,
    awful.layout.suit.tile.top,
    awful.layout.suit.tile.bottom,
	awful.layout.suit.tile,
    awful.layout.suit.tile.left,
    -- tile_bottom_mouse,                          -- CUSTOM: Enhanced tile.bottom with mouse resize
    -- awful.layout.suit.fair.horizontal,
	-- bling.layout.horizontal,          -- OPTIONAL: Horizontal master layout  
    -- lain.layout.termfair.center,
    -- awful.layout.suit.corner.ne,
    -- awful.layout.suit.corner.nw,
	-- awful.layout.suit.spiral,                -- RECOMMENDED: Fibonacci spiral layout
	treetile,
	bling.layout.equalarea,              -- RECOMMENDED: Equal area distribution
	bling.layout.mstab,                -- HIGHLY RECOMMENDED: Master-slave tabbing
	-- bling.layout.vertical,            -- OPTIONAL: Vertical master layout
    -- lain.layout.centerwork,
    -- lain.layout.termfair,
    awful.layout.suit.magnifier,
	bling.layout.deck,                -- OPTIONAL: Deck-style stacking layout
    lain.layout.cascade,                     -- RECOMMENDED: Beautiful cascading windows
    awful.layout.suit.max,
	--
	--    -- BLING LAYOUTS (uncomment if you install Bling):
    awful.layout.suit.floating,
	bling.layout.centered,           -- RECOMMENDED: Centered layout
	--    -- Disabled layouts (commented out for reference)
	--    -- awful.layout.suit.corner.nw,
	--    -- awful.layout.suit.corner.ne,
	--    -- awful.layout.suit.spiral.dwindle,
	--    awful.layout.suit.max.fullscreen,
	--    leaved.layout.suit.tile.right,
	-- 	leaved.layout.suit.tile.left,
	-- 	leaved.layout.suit.tile.bottom,
	-- 	leaved.layout.suit.tile.top,
	trizen, 
	-- dovetail.layout.right,
	-- dynamite.layout.conditional,
	-- dynamite.layout.ratio,
	-- dynamite.layout.stack,
	-- dynamite.layout.tabbed
}


-- // MARK: WIDGETS
-- ################################################################################
-- ██╗    ██╗██╗██████╗  ██████╗ ███████╗████████╗███████╗
-- ██║    ██║██║██╔══██╗██╔════╝ ██╔════╝╚══██╔══╝██╔════╝
-- ██║ █╗ ██║██║██║  ██║██║  ███╗█████╗     ██║   ███████╗
-- ██║███╗██║██║██║  ██║██║   ██║██╔══╝     ██║   ╚════██║
-- ╚███╔███╔╝██║██████╔╝╚██████╔╝███████╗   ██║   ███████║
--  ╚══╝╚══╝ ╚═╝╚═════╝  ╚═════╝ ╚══════╝   ╚═╝   ╚══════╝
-- ################################################################################
-- WIDGETS - menus, widgets, and interface elements

-- // MARK: --menu
-- MENU - Application menu configuration
-- Create the awesome submenu contents
awesomesubmenu = {
    {"Hotkeys", function() hotkeys_popup.show_help(nil, awful.screen.focused()) end},
    {"Manual", terminal .. " -e man awesome"},
    {"Edit config", editor_cmd .. " " .. awesome.conffile},
    {"Restart", awesome.restart},
    {"Quit", function() awesome.quit() end}
}
-- Build the main menu with the submenu, app launcher, and terminal entry
mymainmenu = freedesktop.menu.build({
    before = {
        {"Awesome", awesomesubmenu, beautiful.awesome_icon}
        -- other triads can be put here
    },
    after = {
        {"Terminal", terminal}
        -- other triads can be put here
    }
})

-- Create a launcher widget and a main menu
mylauncher = awful.widget.launcher({
    image = beautiful.awesome_icon,
    menu = mymainmenu
})

-- Keyboard map indicator and switcher
mykeyboardlayout = awful.widget.keyboardlayout()

-- Add icon entries to desktop (disabled)
-- for s in screen do
--     freedesktop.desktop.add_icons({screen = s})
-- end

-- // MARK: --navigation
-- Navigation system using collision detection
require("collision") {
    -- Vim-style movement keys
    up    = { "k" },
    down  = { "j" },
    left  = { "h" },
    right = { "l" },

    -- Other configurations (commented out)
    -- Normal arrow keys
    -- up    = { "Up"    },
    -- down  = { "Down"  },
    -- left  = { "Left"  },
    -- right = { "Right" },

    -- Multiple key options
    -- up    = { "Up", "&", "k", "F15" },
    -- down  = { "Down", "KP_Enter", "j", "F14" },
    -- left  = { "Left", "#", "h", "F13" },
    -- right = { "Right", "\"", "l", "F17" },
}

-- Alt-Tab alternatives (disabled)
-- local switcher = require("awesome-switcher")
-- awful.key({ "Mod1" }, "Tab", function() switcher.switch(1, "Alt_L", "Tab", "ISO_Left_Tab") end)
-- awful.key({ "Mod1", "Shift" }, "Tab", function() switcher.switch(-1, "Alt_L", "Tab", "ISO_Left_Tab") end)

-- Alternative Alt-Tab implementation (disabled)
-- local alttab = require("gobo.awesome.alttab")
-- awful.key({ "Mod1" }, "Tab", function() alttab.switch(1, "Alt_L", "Tab", "ISO_Left_Tab") end,
--    { description = "Switch between windows", group = "awesome" })
-- awful.key({ "Mod1", "Shift" }, "Tab", function() alttab.switch(-1, "Alt_L", "Tab", "ISO_Left_Tab") end,
--    { description = "Switch between windows backwards", group = "awesome" })






-- Active layout scripts
local treetile = require("treetile")

-- Disabled/Alternative layout scripts (commented out for reference)
-- local dovetail = require("awesome-dovetail")
-- local thrizen = require("thrizen")
-- local leaved = require("awesome-leaved")

-- Titlebar customization (disabled)
-- local fenetre = require("fenetre")
-- fenetre { order = { "max", "ontop", "sticky", "floating", "close" } }

-- Grid-based tag navigation (disabled)
-- local workspace_grid = require("awesome-workspace-grid")
-- grid = workspace_grid({
--     rows = 3,
--     columns = 4,
--     cycle = true,
--     icon_size = 100,
--     position = "bottom_middle",
--     visual = true
-- })

-- Multi-app navigation (disabled)
-- Unified cross AwesomeWM window / Vim pane / Tmux pane hotkey navigation
-- require("awesomewm-vim-tmux-navigator"){
--     up    = {"Up", "k"},
--     down  = {"Down", "j"},
--     left  = {"Left", "h"},
--     right = {"Right", "l"},
-- }

-- Additional utilities (disabled)
-- local xrandr = require("xrandr")
-- local mpris_widget = require("awesome-wm-widgets.mpris-widget")
-- local mpris_widget = require("plugins.media")
-- local media_player = require("media-player")


-- // MARK: --session
-- SESSION - Session management
-- Reactivate tabs that were active before a restart of awesomewm
-- For Firefox, might have to disable widget.disable-workspace-management in about:config
-- https://www.reddit.com/r/awesomewm/comments/syjolb/preserve_previously_used_tag_between_restarts/
awesome.connect_signal('exit', function(reason_restart)
	if not reason_restart then return end
	local file = io.open('/tmp/awesomewm-last-selected-tags', 'w+')
	for s in screen do
		file:write(s.selected_tag.index, '\n')
	end
	file:close()
end)

awesome.connect_signal('startup', function()
	local file = io.open('/tmp/awesomewm-last-selected-tags', 'r')
	if not file then return end
	local selected_tags = {}
	for line in file:lines() do
		table.insert(selected_tags, tonumber(line))
	end
	for s in screen do
		local i = selected_tags[s.index]
		local t = s.tags[i]
		t:view_only()
	end
	file:close()
end)


-- // MARK: --borders-shimmer
-- MARK: BORDERS / SHIMMER - Create a cycling rainbow animation for focused window borders

-- Border animation variables (moved here to avoid forward reference)
border_animate_colours = {}
local borderLoop = 1
local borderStep = 1 -- 1 for forward, -1 for reverse

-- Gradient generator function
-- Adapted from https://krazydad.com/tutorials/makecolors.php
function makeColorGradient(frequency1, frequency2, frequency3, phase1, phase2, phase3, center, width, len)
    if center == nil then center = 128 end
    if width == nil then width = 127 end
    if len == nil then len = 120 end

    genLoop = 0
    while genLoop < len do
        -- Calculate RGB values using sine waves
        red = string.format("%02x", math.floor(math.sin(frequency1 * genLoop + phase1) * width + center))
        grn = string.format("%02x", math.floor(math.sin(frequency2 * genLoop + phase2) * width + center))
        blu = string.format("%02x", math.floor(math.sin(frequency3 * genLoop + phase3) * width + center))

        -- Store the hex color
        border_animate_colours[genLoop] = "#" .. red .. grn .. blu
        genLoop = genLoop + 1
    end
end

-- Color parameters - final settings
-- a = 0.8
-- redFrequency = 0.4718/a
-- grnFrequency = 0.1618/a
-- bluFrequency = 0.1/a
-- phase1 = 0
-- phase2 = 120
-- phase3 = 270
-- center = 185
-- width = 65
-- len = 2600

-- Alternative aesthetics (uncomment to try different effects)
--
-- [[ Subtle pastels ]]
-- a = 1.0
-- redFrequency = 0.3
-- grnFrequency = 0.3
-- bluFrequency = 0.3
-- phase1 = 0
-- phase2 = 2
-- phase3 = 4
-- center = 210
-- width = 45
-- len = 800
--
-- [[ High contrast neon ]]
-- redFrequency = 0.1
-- grnFrequency = 0.2
-- bluFrequency = 0.3
-- phase1 = 0
-- phase2 = 120
-- phase3 = 240
-- center = 128
-- width = 127
-- len = 1000
--
-- [[ Cyberpunk palette ]]
-- redFrequency = 0.1
-- grnFrequency = 0.2
-- bluFrequency = 0.1
-- phase1 = 1
-- phase2 = 260
-- phase3 = 50
-- center = 180
-- width = 75
-- len = 1500
--
-- [[ Monochrome grayscale ]]
-- redFrequency = 0.3
-- grnFrequency = 0.3
-- bluFrequency = 0.3
-- phase1 = 10
-- phase2 = 10
-- phase3 = 10
-- center = 200
-- width = 50
-- len = 1200

-- Color parameters - final settings (moved here to avoid forward reference)
redFrequency = 0.1
grnFrequency = 0.2
bluFrequency = 0.1
phase1 = 1
phase2 = 260
phase3 = 50
center = 180
width = 75
len = 1500

-- Generate the color palette with current settings
makeColorGradient(redFrequency, grnFrequency, bluFrequency, phase1, phase2, phase3, center, width, len)

-- Timer for cycling border colors
border_animation_timer = gears.timer {
    timeout = 0.15,
    autostart = false, -- Start only when needed
    callback = function()
        local c = client.focus
        if not c then
            border_animation_timer:stop() -- Pause when no client is focused
            return
        end

        -- don't animate border during drag
        if c._dnd_dragging or (awesome_dnd and awesome_dnd.drag_active) then
            return
        end

        -- Update the color index and handle direction changes (0..len-1 range)
        borderLoop = borderLoop + borderStep
        if borderLoop >= (len - 1) then
            borderLoop = len - 1
            borderStep = -1 -- Reverse direction
        elseif borderLoop <= 0 then
            borderLoop = 0
            borderStep = 1 -- Forward direction
        end

        -- Apply the current color
        c.border_color = border_animate_colours[borderLoop]
    end
}

-- Start animation when a window gets focus
client.connect_signal("focus", function(c)
    -- don't override border during drag
    if c._dnd_dragging or (awesome_dnd and awesome_dnd.drag_active) then
        return
    end
    borderLoop = 0 -- Reset to start
    borderStep = 1
    c.border_color = border_animate_colours[borderLoop]

    -- Start the animation timer if not already running
    if not border_animation_timer.started then
        border_animation_timer:start()
    end
end)

-- Reset border color on unfocus
client.connect_signal("unfocus", function(c)
    c.border_color = "#00000000" -- Transparent black
end)

-- Store widget references for direct updates (moved here to avoid nil reference)
-- (moved earlier) local active_tag_widgets = {}
-- (moved earlier) local active_client_widgets = {}

-- ========================================================================
-- SHIMMER ANIMATION SYSTEM
-- ========================================================================
-- Provides text shimmer effects for window titles, tags, and UI elements.
-- Supports multiple animation modes: candle flicker, cloud shadows,
-- character flicker, border sync, and off.
-- ========================================================================

-- Base gold color settings
local dark_gold = "#8B6914"   -- Darker, more dramatic gold
local base_gold = "#FFD700"   -- Base gold color (medium)
local light_gold = "#FFFACD"  -- Lighter, more vibrant gold

-- Shimmer animation modes configuration
local shimmer_config = {
    -- Candle flicker mode - mimics a flickering candle
    candle = {
        speed = 0.12,           -- Timer interval in seconds (try 0.08 for faster flicker)
        intensity = 0.8,        -- How much variation (0-1) (try 0.4 for more dramatic)
        randomness = 0.8,       -- Random flicker amount (0-1) (try 0.6 for more chaos)
        base_phase = 0,         -- Current phase
        random_offset = 0       -- Random offset for flicker
    },
    
    -- Cloud shadow mode - like clouds passing over the sun
    cloud = {
        speed = 0.08,           -- Timer interval in seconds (try 0.05 for faster clouds)
        intensity = 0.7,        -- How much variation (0-1) (try 0.3 for more dramatic)
        wave_length = 120,      -- Length of the wave cycle (try 80 for shorter waves)
        base_phase = 0          -- Current phase
    },
    
    -- Character flicker mode - each character shimmers independently
    char_flicker = {
        speed = 0.15,           -- Timer interval in seconds (try 0.10 for faster flicker)
        intensity = 0.6,        -- How much variation (0-1) (try 0.35 for more dramatic)
        char_phases = {},       -- Individual phases for each character
        random_factor = 0.9     -- How random the character timing is (increased for more independence)
    },
    
    -- Border sync mode - follows animated border colors with configurable phase offset
    border_sync = {
        speed = 0.15,           -- Match border animation speed exactly
        intensity = 1.0,        -- Full intensity to match border colors exactly
        phase_offset = 0        -- Phase offset to sync with border animation
    },
    
    -- Deep gold mode - rich golds/ambers/purples avoiding whites/greys
    deep_gold = {
        speed = 0.30,
        intensity = 0.8,
        min_factor = 0.15,      -- Avoid light colors
        max_factor = 0.75       -- Cap brightness to avoid near-white
    }
}

-- Current animation mode ('candle', 'cloud', 'char_flicker', 'border_sync', or 'off')
shimmer_mode = "border_sync"

-- Function to blend two colors
local function blend_colors(color1, color2, factor)
    -- Parse hex colors
    local r1 = tonumber(color1:sub(2, 3), 16)
    local g1 = tonumber(color1:sub(4, 5), 16)
    local b1 = tonumber(color1:sub(6, 7), 16)
    
    local r2 = tonumber(color2:sub(2, 3), 16)
    local g2 = tonumber(color2:sub(4, 5), 16)
    local b2 = tonumber(color2:sub(6, 7), 16)
    
    -- Blend the colors
    local r = math.floor(r1 + (r2 - r1) * factor)
    local g = math.floor(g1 + (g2 - g1) * factor)
    local b = math.floor(b1 + (b2 - b1) * factor)
    
    return string.format("#%02x%02x%02x", r, g, b)
end

-- Generate shimmer color based on mode
local function get_shimmer_color(mode_config, text_length)
    local config = shimmer_config[mode_config or shimmer_mode]
    if not config then return base_gold end
    
    local factor = 0.5  -- Start from middle (base gold)
    
    if mode_config == "candle" or (not mode_config and shimmer_mode == "candle") then
        -- Candle flicker: base sine wave + random flicker
        local base_flicker = math.sin(config.base_phase) * 0.5 + 0.5
        local random_flicker = config.random_offset
        local shimmer_amount = (base_flicker * 0.7 + random_flicker * 0.3) * config.intensity
        factor = 0.5 + (shimmer_amount - 0.5) * 1.0  -- Center around 0.5 (base gold)
        
    elseif mode_config == "cloud" or (not mode_config and shimmer_mode == "cloud") then
        -- Cloud shadow: smooth sine wave
        local shimmer_amount = (math.sin(config.base_phase * 2 * math.pi / config.wave_length) * 0.5 + 0.5) * config.intensity
        factor = 0.5 + (shimmer_amount - 0.5) * 1.0  -- Center around 0.5 (base gold)
        
    elseif mode_config == "char_flicker" or (not mode_config and shimmer_mode == "char_flicker") then
        -- For character flicker, we'll return the base color and handle individual chars elsewhere
        local shimmer_amount = 0.15 * config.intensity
        factor = 0.5 + (shimmer_amount - 0.5) * 1.0  -- Center around 0.5 (base gold)
        
    elseif mode_config == "border_sync" or (not mode_config and shimmer_mode == "border_sync") then
        -- Border sync mode - use color offset from the animated border for phase shift
        if border_animate_colours and borderLoop and len then
            -- Phase offset for title text (adjust this value to change phase relationship)
            local phase_offset = math.floor(len * 0.3)  -- 30% of cycle ahead
            local title_loop = borderLoop + phase_offset
            
            -- Handle wraparound for smooth cycling
            if title_loop >= len then
                title_loop = title_loop - len
            elseif title_loop < 0 then
                title_loop = title_loop + len
            end
            
            local color = border_animate_colours[title_loop]
            if not color then return base_gold end
                            -- print("Border sync: borderLoop=" .. borderLoop .. ", color=" .. color)
            return color
        else
            -- Fallback to base gold if border colors aren't available
                            -- print("Border sync fallback: border_animate_colours=" .. tostring(border_animate_colours) .. ", borderLoop=" .. tostring(borderLoop))
            return base_gold
        end
    elseif mode_config == "deep_gold" or (not mode_config and shimmer_mode == "deep_gold") then
        -- Deep gold mode: rich spectrum avoiding whites/greys
        local base_flicker = math.sin(config.base_phase or 0) * 0.5 + 0.5
        local shimmer_amount = base_flicker * config.intensity
        factor = config.min_factor + shimmer_amount * (config.max_factor - config.min_factor)
    end
    
    -- Clamp factor to 0-1 range
    factor = math.max(0, math.min(1, factor))
    
    -- Choose color palette based on mode
    local color
    if mode_config == "deep_gold" or (not mode_config and shimmer_mode == "deep_gold") then
        -- Deep gold palette: rich amber to deep purple, avoiding whites
        local deep_amber = "#B8860B"  -- Dark goldenrod
        local rich_purple = "#8B4B9B" -- Rich purple
        color = blend_colors(deep_amber, rich_purple, factor)
    else
        -- Normal shimmer colors
        color = blend_colors(dark_gold, light_gold, factor)
    end
    
    -- Use full range from dark gold to light gold for dramatic effect
    return color
end

-- Get character-specific color for flicker mode
local function get_char_shimmer_color(char_index, text_length)
    local config = shimmer_config.char_flicker
    
    -- Initialize character phase if not exists with much more variation
    if not config.char_phases[char_index] then
        -- Give each character a truly unique starting phase
        config.char_phases[char_index] = (char_index * 1.7 + math.random() * 3.14) * 2 * math.pi
    end
    
    -- Each character has its own phase offset
    local char_phase = config.char_phases[char_index]
    
    -- Use different sine functions for more variation
    local base_sine = math.sin(char_phase)
    local secondary_sine = math.cos(char_phase * 1.3)  -- Different frequency
    local combined_sine = (base_sine * 0.7 + secondary_sine * 0.3) * 0.5 + 0.5
    
    local shimmer_amount = combined_sine * config.intensity
    local factor = 0.5 + (shimmer_amount - 0.5) * 1.0  -- Center around 0.5 (base gold)
    
    -- Clamp factor to 0-1 range
    factor = math.max(0, math.min(1, factor))
    
    -- Use full range from dark gold to light gold for dramatic effect
    return blend_colors(dark_gold, light_gold, factor)
end

-- Apply shimmer effect to widget
local function apply_shimmer_to_widget(widget, text, status_symbols)
    if shimmer_mode == "off" then
        if widget.set_markup then
            local full_text = (status_symbols or "") .. text
            widget:set_markup('<span color="' .. base_gold .. '">' .. full_text .. '</span>')
        end
        return
    end
    
    local markup = ""
    local prefix = status_symbols or ""
    
    if shimmer_mode == "char_flicker" then
        -- Character-by-character flicker - apply to client name only
        -- Keep status symbols with base color
        if prefix ~= "" then
            markup = '<span color="' .. base_gold .. '">' .. prefix .. '</span>'
        end

        for i = 1, #text do
            local char = text:sub(i, i)
            local color = get_char_shimmer_color(i, #text)
            markup = markup .. '<span color="' .. color .. '">' .. char .. '</span>'
        end
    else
        -- Uniform shimmer - apply to client name only
        local color = get_shimmer_color()
        if prefix ~= "" then
            markup = '<span color="' .. base_gold .. '">' .. prefix .. '</span><span color="' .. color .. '">' .. text .. '</span>'
        else
            markup = '<span color="' .. color .. '">' .. text .. '</span>'
        end
    end
    
    if widget.set_markup then
        widget:set_markup(markup)
    end
    
    -- Debug: Print client shimmer application (disabled for cleaner output)
    -- if text ~= "⚙" then  -- Don't spam with launcher updates
    --     print("Applied shimmer (" .. shimmer_mode .. ") to '" .. text .. "': " .. markup)
    -- end
end

-- Create a shimmering text launcher (moved here to avoid nil reference)
local launcher_text = wibox.widget {
    markup = '<span color="' .. base_gold .. '">⚙</span>',  -- Gear icon as text
    font = "Hack Nerd Font 16",
    widget = wibox.widget.textbox
}

-- Make launcher text clickable
launcher_text:buttons(gears.table.join(
    awful.button({}, 1, function() mymainmenu:toggle() end),
    awful.button({}, 3, function() mymainmenu:toggle() end)
))

-- Update launcher text with shimmer (moved here to avoid nil reference)
local function update_launcher_shimmer()
    -- Always use static base gold color for launcher (no animation)
    launcher_text:set_markup('<span color="' .. base_gold .. '">⚙</span>')
end

-- Handle client focus changes for shimmer animation
client.connect_signal("focus", function(c)
    print("Client focus changed to: " .. (c.name or c.class or "unknown"))
    -- Reset all client widgets to base color first
    for s in screen do
        local client_widgets = active_client_widgets[s.index] or {}
        for _, widget in pairs(client_widgets) do
            if widget.textbox and widget.textbox.set_markup and widget.client and widget.client.valid then
                local client_name = widget.client.name or widget.client.class or ""
                local status_prefix = ""
                
                -- Build status symbols based on client properties
                local symbols = {}
                local c = widget.client
                if c.floating then table.insert(symbols, "✈") end
                if c.maximized then table.insert(symbols, "+")
                elseif c.maximized_horizontal then table.insert(symbols, "⬌")
                elseif c.maximized_vertical then table.insert(symbols, "⬍") end
                if c.sticky then table.insert(symbols, "▪") end
                if c.ontop then table.insert(symbols, "⌃")
                elseif c.above then table.insert(symbols, "▴")
                elseif c.below then table.insert(symbols, "▾") end
                
                if #symbols > 0 then
                    status_prefix = table.concat(symbols, "") .. " "
                end
                
                -- Set to base gold for unfocused clients (prefix and title split)
                local pb = widget.prefixbox
                if pb and pb.set_markup then
                    pb:set_markup('<span color="' .. base_gold .. '">' .. ((status_prefix and #status_prefix > 0) and status_prefix or ' ') .. '</span>')
                    -- widget.textbox:set_markup('<span color="' .. base_gold .. '">' .. client_name .. '</span>')  -- original gold color
                    widget.textbox:set_markup('<span color="white">' .. client_name .. '</span>')  -- white color for non-focused clients
                else
                    -- widget.textbox:set_markup('<span color="' .. base_gold .. '">' .. (status_prefix or '') .. client_name .. '</span>')  -- original gold color
                    widget.textbox:set_markup('<span color="white">' .. (status_prefix or '') .. client_name .. '</span>')  -- white color for non-focused clients
                end
            end
        end
    end
    
    -- Apply shimmer to the newly focused client
    if shimmer_mode ~= "off" then
        local client_name = c.name or c.class or ""
        local status_prefix = get_client_status_prefix(c)
        
        -- Find and update the focused client's widget
        local s = c.screen
        local client_widgets = active_client_widgets[s.index] or {}
        for _, widget in pairs(client_widgets) do
            if widget.client and widget.client.valid and widget.client == c then
                local pb = widget.prefixbox
                if pb and pb.set_markup then
                    pb:set_markup('<span color="' .. base_gold .. '">' .. ((status_prefix and #status_prefix > 0) and status_prefix or ' ') .. '</span>')
                end
                apply_shimmer_to_widget(widget.textbox, client_name, nil)
                break
            end
        end
    end
end)



-- More dramatic color range for better visibility (already declared above)
-- local dark_gold = "#8B6914"   -- Darker, more dramatic gold
-- local base_gold = "#FFD700"   -- Base gold color (medium)
-- local light_gold = "#FFFACD"  -- Lighter, more vibrant gold

local gold_shimmer_colors = {}

-- Animation modes configuration (already declared above)
-- You can adjust these values to customize the shimmer effects:
-- - speed: Lower values = faster animation (0.05-0.3 recommended)
-- - intensity: Higher values = more dramatic color changes (0.1-0.5 recommended)
-- - Candle mode: Adds randomness for flickering candle effect
-- - Cloud mode: Smooth wave-like transitions
-- - Character flicker: Each character shimmers independently

-- local shimmer_config = { ... } -- Already declared above
-- local shimmer_mode = "candle" -- Already declared above

-- Function to blend two colors (already declared above)
-- local function blend_colors(color1, color2, factor) { ... } -- Already declared above

-- Generate shimmer color based on mode (already declared above)
-- local function get_shimmer_color(mode_config, text_length) { ... } -- Already declared above

-- Get character-specific color for flicker mode (already declared above)
-- local function get_char_shimmer_color(char_index, text_length) { ... } -- Already declared above
-- Apply shimmer effect to widget (already declared above)
-- local function apply_shimmer_to_widget(widget, text, status_symbols) { ... } -- Already declared above

-- Store widget references for direct updates (already declared above)

-- Debug: Test notification system at startup (disabled)
-- naughty.notify({
--     title = "Shimmer System Starting",
--     text = "Initializing shimmer timer...",
--     timeout = 3
-- })

-- Simple test timer removed - shimmer is working

-- Global timer counter
local timer_count = 0

-- Timer for shimmer animation
shimmer_timer = gears.timer {
    timeout = 0.12, -- Default speed, will be updated dynamically
    autostart = false, -- Start manually after test
    callback = function()
        if shimmer_mode == "off" then
            shimmer_timer:stop()
            return
        end
        
        local config = shimmer_config[shimmer_mode]
        if not config then
            return
        end
        
        -- Update timer speed if it changed
        if config.speed and shimmer_timer.timeout ~= config.speed then
            shimmer_timer.timeout = config.speed
        end
        
        -- Update animation states
        if shimmer_mode == "candle" then
            config.base_phase = config.base_phase + 0.1
            if math.random() < 0.3 then  -- 30% chance for new random flicker
                config.random_offset = (math.random() - 0.5) * config.randomness
            end
            
        elseif shimmer_mode == "cloud" then
            config.base_phase = config.base_phase + 1
            if config.base_phase >= config.wave_length then
                config.base_phase = 0
            end
            
        elseif shimmer_mode == "char_flicker" then
            -- Update individual character phases with much more randomness
            for i, phase in pairs(config.char_phases) do
                -- Each character gets its own random speed and direction
                local random_speed = 0.05 + math.random() * 0.15  -- Random speed between 0.05 and 0.20
                local random_direction = (math.random() - 0.5) * config.random_factor * 0.3
                config.char_phases[i] = phase + random_speed + random_direction
            end
        elseif shimmer_mode == "deep_gold" then
            config.base_phase = (config.base_phase or 0) + 0.1
        end
        
        -- Debug: Print current shimmer state (only occasionally)
        if math.floor(config.base_phase or 0) % 10 == 0 then
            -- print("Shimmer update - mode:", shimmer_mode, "phase:", config.base_phase or "N/A", "focused client:", client.focus and (client.focus.name or client.focus.class or "unknown") or "none")
        end
        
        -- Update shimmer only on the screen with the focused client
        if client.focus then
            local focused_screen = client.focus.screen
            
            -- Update active tag shimmer only on the focused client's screen
            if focused_screen.selected_tag then
                local tag_name = focused_screen.selected_tag.name or ""
                local tag_widgets = active_tag_widgets[focused_screen.index] or {}
                for _, widget in pairs(tag_widgets) do
                    if widget.tag == focused_screen.selected_tag then
                        apply_shimmer_to_widget(widget.textbox, tag_name, nil)
                    end
                end
            end
            
            -- Apply shimmer to focused client
            local client_widgets = active_client_widgets[focused_screen.index] or {}
            
            for _, widget in pairs(client_widgets) do
                if widget.client and widget.client.valid and widget.client == client.focus then
                    local client_name = widget.client.name or widget.client.class or ""
                    -- update split prefix box instead of embedding in title
                    if widget.prefixbox and widget.prefixbox.set_markup then
                        local sp = get_client_status_prefix(widget.client)
                        widget.prefixbox:set_markup('<span color="' .. base_gold .. '">' .. (sp or '') .. '</span>')
                    end
                    apply_shimmer_to_widget(widget.textbox, client_name, nil)
                    break -- Only update the first matching widget
                end
            end
        end
        
        -- Update launcher shimmer
        update_launcher_shimmer()
    end
}

-- Start shimmer timer immediately instead of delay (notifications disabled)
if shimmer_timer then
    local success, err = pcall(function() 
        shimmer_timer:start() 
    end)
    -- Success/error notifications disabled for cleaner startup
end
-- Function to change shimmer mode
function set_shimmer_mode(mode)
    -- print("Setting shimmer mode to: " .. mode)
    shimmer_mode = mode
    if mode == "off" then
        shimmer_timer:stop()
        -- Reset all widgets to base gold
        for s in screen do
            -- Reset tag widgets
            if s.mytaglist then s.mytaglist:emit_signal("widget::redraw_needed") end
            
            -- Reset client widgets
            local client_widgets = active_client_widgets[s.index] or {}
            for _, widget in pairs(client_widgets) do
                if widget.textbox and widget.textbox.set_markup and widget.client and widget.client.valid then
                    local client_name = widget.client.name or widget.client.class or ""
                    local status_prefix = ""
                    
                    -- Build status symbols based on client properties
                    local symbols = {}
                    local c = widget.client
                    if c.floating then table.insert(symbols, "✈") end
                    if c.maximized then table.insert(symbols, "+")
                    elseif c.maximized_horizontal then table.insert(symbols, "⬌")
                    elseif c.maximized_vertical then table.insert(symbols, "⬍") end
                    if c.sticky then table.insert(symbols, "▪") end
                    if c.ontop then table.insert(symbols, "⌃")
                    elseif c.above then table.insert(symbols, "▴")
                    elseif c.below then table.insert(symbols, "▾") end
                    
                    if #symbols > 0 then
                        status_prefix = table.concat(symbols, "") .. " "
                    end
                    
                    -- widget.textbox:set_markup('<span color="' .. base_gold .. '">' .. status_prefix .. client_name .. '</span>')  -- original gold color
                    widget.textbox:set_markup('<span color="white">' .. status_prefix .. client_name .. '</span>')  -- white color for non-focused clients
                end
            end
            
            if s.mytasklist then s.mytasklist:emit_signal("widget::redraw_needed") end
        end
    else
        -- Reset character phases when switching to character flicker for fresh independence
        if mode == "char_flicker" then
            shimmer_config.char_flicker.char_phases = {}
        end
        
        shimmer_timer.timeout = shimmer_config[mode].speed
        if not shimmer_timer.started then
            shimmer_timer:start()
        end
        
        -- Apply shimmer to currently focused client if any
        if client.focus then
            local c = client.focus
            local client_name = c.name or c.class or ""
            local status_prefix = ""
            
            -- Build status symbols based on client properties
            local symbols = {}
            if c.floating then table.insert(symbols, "✈") end
            if c.maximized then table.insert(symbols, "+")
            elseif c.maximized_horizontal then table.insert(symbols, "⬌")
            elseif c.maximized_vertical then table.insert(symbols, "⬍") end
            if c.sticky then table.insert(symbols, "▪") end
            if c.ontop then table.insert(symbols, "⌃")
            elseif c.above then table.insert(symbols, "▴")
            elseif c.below then table.insert(symbols, "▾") end
            
            if #symbols > 0 then
                status_prefix = table.concat(symbols, "") .. " "
            end
            
            -- Find and update the focused client's widget
            local s = c.screen
            local client_widgets = active_client_widgets[s.index] or {}
            for _, widget in pairs(client_widgets) do
                if widget.client == c then
                    if widget.prefixbox and widget.prefixbox.set_markup then
                        widget.prefixbox:set_markup('<span color="' .. base_gold .. '">' .. ((status_prefix and #status_prefix > 0) and status_prefix or ' ') .. '</span>')
                    end
                    apply_shimmer_to_widget(widget.textbox, client_name, nil)
                    break
                end
            end
        end
    end
end

-- screen setup and widget creation
local taglist_buttons = gears.table.join(
    awful.button({ }, 1, function(t) t:view_only() end),
    awful.button({ modkey }, 1, function(t)
        if client.focus then
            client.focus:move_to_tag(t)
        end 
    end),
    awful.button({ }, 3, awful.tag.viewtoggle),
    awful.button({ modkey }, 3, function(t)
        if client.focus then
            client.focus:toggle_tag(t)
        end
    end), 
    awful.button({ }, 4, function(t) awful.tag.viewnext(t.screen) end),
    awful.button({ }, 5, function(t) awful.tag.viewprev(t.screen) end)
)

local tasklist_buttons = gears.table.join(
    awful.button({ }, 1, function (c)
        if c == client.focus then
            c.minimized = true
        else
            c:emit_signal(
                "request::activate",
                "tasklist",
                {raise = true}
            )
        end
    end),
    awful.button({ }, 2, function (c)
        c.minimized = true
    end),
    awful.button({ }, 3, function()
        awful.menu.client_list({ theme = { width = 250 } })
    end),
    awful.button({ }, 4, function ()
        awful.client.focus.byidx(1)
    end),
    awful.button({ }, 5, function ()
        awful.client.focus.byidx(-1)
    end)
)

-- apply wallpaper and create widgets for each screen
awful.screen.connect_for_each_screen(function(s)
    -- wallpaper
    set_wallpaper(s)

    -- {{{ Quake terminal
    -- Create a dropdown terminal that appears from the top of the screen
    s.quake = lain.util.quake(
        {app = terminal},
        {settings = function(c) c.followtag = true end}
    )

    -- each screen has its own tag table
    awful.tag({ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "="}, s, awful.layout.layouts[1])

    -- create a promptbox for each screen
    s.mypromptbox = awful.widget.prompt()

    -- create an imagebox widget which will contain an icon indicating which layout we're using
    s.mylayoutbox = awful.widget.layoutbox(s)
    s.mylayoutbox:buttons(gears.table.join(
                           awful.button({ }, 1, function () awful.layout.inc( 1) end),
                           awful.button({ }, 3, function () awful.layout.inc(-1) end),
                           awful.button({ }, 4, function () awful.layout.inc( 1) end),
                           awful.button({ }, 5, function () awful.layout.inc(-1) end)))
    
    -- create a taglist widget
    s.mytaglist = awful.widget.taglist {
        screen  = s,
        filter  = awful.widget.taglist.filter.all,
        buttons = taglist_buttons,
        style = {
            squares_sel = nil,
            squares_unsel = nil,
            squares_sel_empty = nil,
            squares_unsel_empty = nil,
            squares_resize = false,
            bg_focus = beautiful.taglist_bg_focus,
            bg_occupied = nil,
        },
        widget_template = {
            -- tag item: overlay square top-left, text shifted right
            {
                {
                    {
                        -- top-left square using place container
                        {
                            id = 'occ_square',
                            forced_width = TAG_SQUARE_SIZE,
                            forced_height = TAG_SQUARE_SIZE,
                            widget = wibox.widget.imagebox,
                        },
                        halign = 'left',
                        valign = 'top',
                        widget = wibox.container.place,
                    },
                    {
                        -- text shifted right to clear the square
                    {
                        id = 'text_role',
                            widget = wibox.widget.textbox,
                        },
                        left = TAG_SQUARE_SIZE + 2,
                        right = 5,
                        top = 0,
                        bottom = 0,
                        widget = wibox.container.margin,
                    },
                    layout = wibox.layout.stack,
                },
                left = 0,
                right = 3,
                top = 0,
                bottom = 0,
                widget = wibox.container.margin,
            },
            id = 'background_role',
            widget = wibox.container.background,
            -- update square based on tag occupancy
            update_callback = function(self, c3, index, objects)
                local tag = c3
                local square_widget = self:get_children_by_id('occ_square')[1]
                if square_widget then
                    local has_unminimized = false
                    if tag then
                        for _, client in ipairs(tag:clients()) do
                            if not client.minimized then
                                has_unminimized = true
                                break
                            end
                    end
                end
                    
                    if has_unminimized then
                        square_widget.image = filled_square
                    elseif tag and #tag:clients() > 0 then
                        square_widget.image = hollow_square
                    else
                        square_widget.image = nil
                    end
                end
            end,
            
            -- create_callback for taglist with shimmer effects and drag-and-drop
            create_callback = function(self, t, index, objects)
                -- Update square when clients are added/removed from tag
                local function update_square()
                    local square_widget = self:get_children_by_id('occ_square')[1]
                    if square_widget then
                        local has_unminimized = false
                        for _, c in ipairs(t:clients()) do
                            if not c.minimized then
                                has_unminimized = true
                                break
                            end
                        end
                        
                        if has_unminimized then
                            square_widget.image = filled_square
                        elseif #t:clients() > 0 then
                            square_widget.image = hollow_square
                        else
                            square_widget.image = nil
                        end
                    end
                end
                
                -- Connect signals for dynamic square updates
                t:connect_signal("property::selected", update_square)
                t:connect_signal("tagged", function(c)
                    if c and c.valid and c.tags then
                        for _, tg in ipairs(c:tags()) do
                            if tg == t then update_square() end
                        end
                    end
                end)
                t:connect_signal("untagged", function(c)
                    if c and c.valid and c.tags then
                        for _, tg in ipairs(c:tags()) do
                            if tg == t then update_square() end
                        end
                    end
                end)
                client.connect_signal("property::minimized", function(c)
                    if c and c.valid and c.tags then
                        for _, tg in ipairs(c:tags()) do
                            if tg == t then update_square() end
                        end
                    end
                end)
                client.connect_signal("property::hidden", function(c)
                    if c and c.valid and c.tags then
                        for _, tg in ipairs(c:tags()) do
                            if tg == t then update_square() end
                        end
                    end
                end)
                
                local text_widget = self:get_children_by_id('text_role')[1]
                if text_widget then
                    -- Initialize screen widgets table
                    if not active_tag_widgets[s.index] then
                        active_tag_widgets[s.index] = {}
                    end
                    
                    -- Store widget reference
                    table.insert(active_tag_widgets[s.index], {
                        tag = t,
                        textbox = text_widget
                    })
                    
                    -- Set initial shimmer if tag is selected
                    if t.selected then
                        apply_shimmer_to_widget(text_widget, t.name or "", nil)
                    end
                end

                -- DnD: highlight on hover and mark as drop target while dragging a client
                if not self._dnd_hooks_installed then
                    self._dnd_hooks_installed = true
                    -- mark widget as a potential drop target for global hover detection
                    self._is_dnd_tag_target = true
                    self._tag_ref = t
                    -- prefer to highlight the background container
                    self._dnd_highlight_widget = self

                    -- also mark inner widgets under the pointer path as drop targets
                    if text_widget and text_widget.valid then
                        text_widget._is_dnd_tag_target = true
                        text_widget._tag_ref = t
                        text_widget._dnd_highlight_widget = self
                    end

                    self:connect_signal('mouse::enter', function()
                        if awesome_dnd and awesome_dnd.drag_active then
                            local target_widget = self._dnd_highlight_widget or self
                            awesome_dnd.set_hover(t, target_widget)
                        else
                            -- Only affect text color if tag is not selected
                            if not t.selected then
                                local text_widget = self:get_children_by_id('text_role')[1]
                                if text_widget and text_widget.set_markup then
                                    local current = t.name or ''
                                    text_widget:set_markup('<span color="' .. (beautiful.taglist_hover_fg or base_gold) .. '">' .. current .. '</span>')
                                    self.__hover_text_colored = true
                                end
                            end
                        end
                    end)

                    self:connect_signal('mouse::leave', function()
                        if awesome_dnd and awesome_dnd.drag_active and awesome_dnd.hovered_tag == t then
                            awesome_dnd.clear_hover()
                        else
                            -- restore text color if we changed it
                            if not t.selected and self.__hover_text_colored then
                                local text_widget = self:get_children_by_id('text_role')[1]
                                if text_widget and text_widget.set_markup then
                                    local current = t.name or ''
                                    text_widget:set_markup('<span color="#FFFFFF">' .. current .. '</span>')
                                end
                                self.__hover_text_colored = nil
                            end
                        end
                    end)
                end
            end,
        }
    }

    -- create a tasklist widget with spacers
    s.mytasklist = awful.widget.tasklist {
        screen  = s,
        filter  = awful.widget.tasklist.filter.currenttags,
        buttons = tasklist_buttons,
        spacing = 2, -- add spacing between task items
        
        -- Template for task items (application buttons)
        widget_template = {
            {
                {
                    {
                        {
                            id = 'icon_role',
                            forced_width = 16,
                            forced_height = 16,
                            widget = wibox.widget.imagebox,
                        },
                        valign = 'center',
                        halign = 'left',
                        widget = wibox.container.place,
                    },
                    {
                        {
                            id = 'status_prefix',
                            widget = wibox.widget.textbox,
                            align = 'left',
                            ellipsize = 'none'
                        },
                        valign = 'center',
                        halign = 'left',
                        widget = wibox.container.place,
                    },
                    { id = 'title_text', widget = wibox.widget.textbox },
                    spacing = 1,
                    layout = wibox.layout.fixed.horizontal,
                },
                left = 3,
                right = 3,
                widget = wibox.container.margin,
            },
            id = 'background_role',
            widget = wibox.container.background,
            
            -- Register textbox for shimmer updates
            create_callback = function(self, c, index, objects)
                local text_widget = self:get_children_by_id('title_text')[1]
                if text_widget then
                    print("Registering client widget for: " .. (c.name or c.class or "unknown"))
                    -- Initialize screen widgets table
                    if not active_client_widgets[s.index] then
                        active_client_widgets[s.index] = {}
                    end
                    
                    -- Store widget reference
                    table.insert(active_client_widgets[s.index], {
                        client = c,
                        textbox = text_widget,
                        prefixbox = self:get_children_by_id('status_prefix')[1]
                    })
                    
                    -- Set initial shimmer if client is focused
                    if client.focus and c.window == client.focus.window then
                        local client = c
                        local text = client.name or client.class or ""
                        local status_prefix = ""
                        
                        -- Build status symbols based on client properties
                        local symbols = {}
                        
                        if client.floating then table.insert(symbols, "✈") end
                        if client.maximized then table.insert(symbols, "+")
                        elseif client.maximized_horizontal then table.insert(symbols, "⬌")
                        elseif client.maximized_vertical then table.insert(symbols, "⬍") end
                        if client.sticky then table.insert(symbols, "▪") end
                        if client.ontop then table.insert(symbols, "⌃")
                        elseif client.above then table.insert(symbols, "▴")
                        elseif client.below then table.insert(symbols, "▾") end
                        
                        if #symbols > 0 then
                            status_prefix = table.concat(symbols, "") .. " "
                        end
                        local prefix_widget = self:get_children_by_id('status_prefix')[1]
                        if prefix_widget then
                            local content = (status_prefix ~= '' and status_prefix) or ''
                            prefix_widget:set_markup('<span color="' .. base_gold .. '">' .. content .. '</span>')
                        end
                        apply_shimmer_to_widget(text_widget, text, nil)
                    end
                end
            end,
            update_callback = function(self, c, index, objects)
                local text_widget = self:get_children_by_id('title_text')[1]
                local prefix_widget = self:get_children_by_id('status_prefix')[1]
                if not text_widget then return end
                local client_name = c.name or c.class or ""
                local status_prefix = get_client_status_prefix(c)
                if prefix_widget then
                    prefix_widget:set_markup('<span color="' .. base_gold .. '">' .. ((status_prefix and #status_prefix > 0) and status_prefix or ' ') .. '</span>')
                end
                        
                -- urxvt icon fallback to generic terminal icon
                local icon_widget = self:get_children_by_id('icon_role')[1]
                if icon_widget and (c.class == 'URxvt' or c.class == 'urxvt') then
                    local term_icon = gears.filesystem.get_configuration_dir() .. 'milktheme/layouts/term.png'
                    if gears.filesystem.file_readable(term_icon) then
                        icon_widget.image = term_icon
                    else
                        icon_widget.image = create_terminal_icon_surface(16)
                    end
                end
                
                if client.focus and c.window == client.focus.window then
                    apply_shimmer_to_widget(text_widget, client_name, nil)
                else
                    text_widget:set_markup('<span color="white">' .. client_name .. '</span>')
                end
            end,
        }
    }

    -- create the wibox
    s.mywibox = awful.wibar({ position = "top", screen = s })

    -- add widgets to the wibox
    s.mywibox:setup {
        layout = wibox.layout.align.horizontal,
        { -- left widgets
            layout = wibox.layout.fixed.horizontal,
            mylauncher,
            s.mylayoutbox,
            s.mytaglist,
            s.mypromptbox,
        },
        s.mytasklist, -- middle widget
        { -- right widgets
            layout = wibox.layout.fixed.horizontal,
            wibox.widget.systray(),
            textclock_clr,
        },
    }

    -- the alt wibox
    s.myaltwibox = awful.wibar({
        position = "top",
        screen = s,
        height = 23,
        visible = false
    })

    -- Add widgets to the wibox
    s.myaltwibox:setup{
        layout = wibox.layout.align.horizontal,
        expand = "none",
        {
            -- Left widgets
            layout = wibox.layout.fixed.horizontal
        },
        -- Middle widget
        -- media_player2,
        {
            -- Right widgets
            layout = wibox.layout.fixed.horizontal
        }
    }
end)

-- Desktop button bindings
root.buttons(gears.table.join(
    awful.button({ }, 3, function () mymainmenu:toggle() end)
))

-- setup drag-and-drop functionality (called after screen setup)
-- (function is defined later in the file)


-- // MARK: SESSION
-- ################################################################################
-- ███████╗███████╗███████╗███████╗██╗ ██████╗ ███╗   ██╗
-- ██╔════╝██╔════╝██╔════╝██╔════╝██║██╔════╝ ████╗  ██║
-- ███████╗███████╗███████╗███████╗██║██║     ██╔██╗ ██║
-- ╚════██║╚════██║╚════██║╚════██║██║██║     ██║╚██╗██║
-- ███████║███████║███████║███████║██║╚██████╗██║ ╚████║
-- ╚══════╝╚══════╝╚══════╝╚══════╝╚═╝ ╚═════╝╚═╝  ╚═══╝
-- ################################################################################
-- SESSION - session management, tag persistence, and client signal handlers

-- Reactivate tabs that were active before a restart of awesomewm
-- For Firefox, might have to disable widget.disable-workspace-management in about:config
-- https://www.reddit.com/r/awesomewm/comments/syjolb/preserve_previously_used_tag_between_restarts/
awesome.connect_signal('exit', function(reason_restart)
    if not reason_restart then return end
    local file = io.open('/tmp/awesomewm-last-selected-tags', 'w+')
    for s in screen do
        file:write(s.selected_tag.index, '\n')
    end
    file:close()
end)

awesome.connect_signal('startup', function()
    local file = io.open('/tmp/awesomewm-last-selected-tags', 'r')
    if not file then return end
    local selected_tags = {}
    for line in file:lines() do
        table.insert(selected_tags, tonumber(line))
    end
    for s in screen do
        local i = selected_tags[s.index]
        if i and s.tags[i] then
            local t = s.tags[i]
            t:view_only()
        end
    end
    file:close()
end)

-- window management signal handlers
client.connect_signal("property::maximized", function(c)
    if c.maximized and (c.class == "Navigator" or c.class == "firefox" or c.class == "Firefox") then
        c.maximized = false
    end
end)

-- make floating windows appear on top by default
client.connect_signal("manage", function(client)
    if client.floating then
        client.ontop = true
    end
end)

-- avoid firefox picture-in-picture popping window up/down when pip meets screen edges
client.connect_signal("property::struts", function(c)
    local struts = c:struts()
    if struts.left ~= 0 or struts.right ~= 0 or
       struts.top ~= 0 or struts.bottom ~= 0 then
        c:struts({left = 0, right = 0, top = 0, bottom = 0})
    end
end)


-- // MARK: --pavucontrol-examples
-- Alternative/complex client rule examples (commented out)
-- Example: Open sound mixer but keep tag visible without switching to it
-- {rule = {instance = "pavucontrol"}, properties = {tag = "9", toggle_tag = true}}

-- Alternative rule implementation with callback to keep tag visible
-- rule {
--     rule = { class = "pavucontrol" },
--     properties = {
--         tag = "9" -- this puts the client on the tag
--     },
--     callback = function(c)
--         -- Show the tag on screen *without* selecting it
--         local s = c.screen or screen.primary
--         local t = my_tag or awful.tag.find_by_name(s, "9")

--         if t and not t.selected then
--             awful.tag.viewtoggle(t)
--         end
--     end
-- }

-- Helper function for complex rules (commented out)
-- -- Get screen under mouse without moving cursor
-- local function get_mouse_screen()
--     local coords = mouse.coords()
--     for s in screen do
--         if coords.x >= s.geometry.x and coords.x < s.geometry.x + s.geometry.width and
--            coords.y >= s.geometry.y and coords.y < s.geometry.y + s.geometry.height then
--             return s
--         end
--     end
--     return screen.primary
-- end

-- -- Handle new pavucontrol instances
-- client.connect_signal("manage", function(c)
--     if c.class == "Pavucontrol" then
--         -- Mark this pavucontrol as just opened
--         pavucontrol_just_opened[c] = true

--         -- Debug: let's see what's happening
--         local mouse_screen = get_mouse_screen()
--         local current_screen = c.screen

--         -- Always move to mouse screen first, before any tag operations
--         if current_screen ~= mouse_screen then
--             c:move_to_screen(mouse_screen)
--         end

--         -- Now work with the correct screen
--         local target_screen = c.screen  -- Use the screen the client is actually on
--         local tag9 = target_screen.tags[9]

--         if tag9 then
--             -- Store current state if tag 9 isn't already selected
--             if not tag9.selected then
--                 local current_tags = target_screen.selected_tags
--                 if #current_tags > 0 then
--                     previous_tag = current_tags[1]
--                 end

--                 -- Keep current tags selected and add tag 9
--                 for _, tag in ipairs(current_tags) do
--                     tag.selected = true
--                 end
--                 tag9.selected = true
--             end
--             c:move_to_tag(tag9)
--         end
--         -- Clear the flag after a delay
--         gears.timer.start_new(0.5, function()
--             pavucontrol_just_opened[c] = nil
--             return false
--         end)
--     end
-- end)

-- -- Handle existing pavucontrol being focused from different screen
-- client.connect_signal("focus", function(c)
--     if c.class == "Pavucontrol" and not pavucontrol_just_opened[c] then
--         local target_screen = get_mouse_screen()

--         -- Only move if pavucontrol is on a different screen than the mouse
--         if c.screen ~= target_screen then
--             c:move_to_screen(target_screen)

--             local tag9 = target_screen.tags[9]
--             if tag9 then
--                 if not tag9.selected then
--                     local current_tags = target_screen.selected_tags
--                     if #current_tags > 0 then
--                         previous_tag = current_tags[1]
--                     end

--                     -- Keep current tags selected and add tag 9
--                     tag9.selected = true
--                 end
--                 c:move_to_tag(tag9)
--             end
--         end
--     end
-- end)

-- -- Handle existing pavucontrol being clicked on different screen
-- client.connect_signal("button::press", function(c)
--     if c.class == "Pavucontrol" then
--         local target_screen = get_mouse_screen()

--         -- Only move if pavucontrol is on a different screen than the mouse
--         if c.screen ~= target_screen then
--             c:move_to_screen(target_screen)

--             local tag9 = target_screen.tags[9]
--             if tag9 then
--                 if not tag9.selected then
--                     local current_tags = target_screen.selected_tags
--                     if #current_tags > 0 then
--                         previous_tag = current_tags[1]
--                     end

--                     -- Keep current tags selected and add tag 9
--                     for _, tag in ipairs(current_tags) do
--                         tag.selected = true
--                     end
--                     tag9.selected = true
--                 end
--                 c:move_to_tag(tag9)
--             end
--         end
--     end
-- end)

-- -- Clean up when pavucontrol closes
-- client.connect_signal("unmanage", function(c)
--     if c.class == "Pavucontrol" then
--         -- Clean up the tracking table
--         pavucontrol_just_opened[c] = nil

--         -- Restore previous tag if needed
--         if previous_tag then
--             previous_tag:view_only()
--             previous_tag = nil
--         end
--     end
-- end)


-- // MARK: CLIENT MANAGEMENT
-- ################################################################################
--  ██████╗██╗     ██╗███████╗███╗   ██╗████████╗    ███╗   ███╗ █████╗ ███╗   ██╗ █████╗  ██████╗ ███████╗███╗   ██╗███████╗██╗  ██╗
-- ██╔════╝██║     ██║██╔════╝████╗  ██║╚══██╔══╝    ████╗ ████║██╔══██╗████╗  ██║██╔══██╗██╔════╝ ██╔════╝████╗  ██║██╔════╝╚██╗██╔╝
-- ██║     ██║     ██║█████╗  ██╔██╗ ██║   ██║       ██╔████╔██║███████║██╔██╗ ██║███████║██║  ███╗█████╗  ██╔██╗ ██║█████╗  ╚███╔╝ 
-- ██║     ██║     ██║██╔══╝  ██║╚██╗██║   ██║       ██║╚██╔╝██║██╔══██║██║╚██╗██║██╔══██║██║   ██║██╔══╝  ██║╚██╗██║██╔══╝  ██╔██╗ 
-- ╚██████╗███████╗██║███████╗██║ ╚████║   ██║       ██║ ╚═╝ ██║██║  ██║██║ ╚████║██║  ██║╚██████╔╝███████╗██║ ╚████║███████╗██╔╝ ██╗
--  ╚═════╝╚══════╝╚═╝╚══════╝╚═╝  ╚═══╝   ╚═╝       ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝
-- ################################################################################
-- CLIENT MANAGEMENT - auto-sizing, focus handling, floating windows, and mouse interactions
-- (consolidated from: AUTO-SIZING, ANTI-WARP RESIZE, FOCUS AND ACTIVATION HANDLING, FLOATING WINDOW CENTER, MOUSE BUTTONS)

-- // MARK: --auto-sizing
--[[ DISABLED: Auto-sizing dialog system was too aggressive
client.connect_signal("manage", function(c)
    -- Wait a moment for the window name to be set
    gears.timer.delayed_call(function()
        if not c.valid then return end
        
        local name = c.name or ""
        local class = c.class or ""
        
        -- Get current geometry to check if window is too small
        local geo = c:geometry()
        local min_width = 400  -- Minimum width threshold
        local min_height = 300 -- Minimum height threshold
        
        -- Only apply auto-floating if window is smaller than threshold
        local should_auto_resize = (geo.width < min_width or geo.height < min_height)
        
        -- Screenshot and image dialogs
        if (name:match("Save screenshot") or name:match("Save Screenshot") or 
           name:match("Screenshot") or name:match("Save Image") or
           name:match("Export Image") or name:match("Export Screenshot")) and should_auto_resize then
            c.floating = true
            c.width = 800
            c.height = 600
            awful.placement.centered(c)
        
        -- File operation dialogs
        elseif (name:match("Save As") or name:match("Open File") or 
               name:match("Choose File") or name:match("File Operations") or
               name:match("Copy Files") or name:match("Move Files")) and should_auto_resize then
            c.floating = true
            c.width = 900
            c.height = 700
            awful.placement.centered(c)
        
        -- Preferences and settings dialogs
        elseif (name:match("Preferences") or name:match("Settings") or 
               name:match("Options") or name:match("Configuration") or
               name:match("Properties")) and should_auto_resize then
            c.floating = true
            c.width = 850
            c.height = 650
            awful.placement.centered(c)
        
        -- Print and export dialogs
        elseif (name:match("Print") or name:match("Export") or 
               name:match("Print Setup") or name:match("Export As")) and should_auto_resize then
            c.floating = true
            c.width = 750
            c.height = 550
            awful.placement.centered(c)
        
        -- Error and confirmation dialogs
        elseif (name:match("Error") or name:match("Warning") or 
               name:match("Confirmation") or name:match("Confirm")) and should_auto_resize then
            c.floating = true
            c.width = 500
            c.height = 300
            awful.placement.centered(c)
        
        -- Browser dialogs
        elseif (name:match("Downloads") or name:match("Bookmarks") or 
               name:match("History") or name:match("Page Info") or
               name:match("Developer Tools")) and should_auto_resize then
            c.floating = true
            c.width = 800
            c.height = 600
            awful.placement.centered(c)
        
        -- Media player dialogs
        elseif (name:match("Media Info") or name:match("Track Info") or 
               name:match("Playlist") or name:match("Audio Settings")) and should_auto_resize then
            c.floating = true
            c.width = 700
            c.height = 500
            awful.placement.centered(c)
        
        -- Development dialogs
        elseif (name:match("Debug") or name:match("Output") or 
               name:match("Terminal") or name:match("Build Output") or
               name:match("Error List")) and should_auto_resize then
            c.floating = true
            c.width = 900
            c.height = 700
            awful.placement.centered(c)
        
        -- Generic dialog catch-all (for any dialog type window)
        elseif c.type == "dialog" and should_auto_resize then
            c.floating = true
            c.width = 600
            c.height = 400
            awful.placement.centered(c)
        end
    end)
end)
--]] -- End of disabled auto-sizing dialog system

-- // MARK: --anti-warp-resize
-- Anti-warp resize function that prevents cursor from jumping to another monitor
local function resize_no_warp(c)
    c:emit_signal("request::activate", "mouse_click", {raise = true})

    -- Check if client is floating or if current layout has mouse_resize_handler
    local layout = awful.layout.get(c.screen)
    
    -- Debug: Always print layout info
    print("resize_no_warp called - Layout:", layout.name or "unknown", "Floating:", c.floating, "Has handler:", layout.mouse_resize_handler and "yes" or "no")
    
    -- If client is not floating and layout has mouse_resize_handler, use it
    if not c.floating and layout.mouse_resize_handler then
        print("Using layout mouse resize handler for:", layout.name or "unknown layout")
        
        local initial_coords = mouse.coords()
        local geo = c:geometry()
        
        -- Determine corner based on mouse position relative to client center  
        local corner
        if initial_coords.y < geo.y + geo.height/2 then
            if initial_coords.x < geo.x + geo.width/2 then
                corner = "top_left"
            else
                corner = "top_right"
            end
        else
            if initial_coords.x < geo.x + geo.width/2 then
                corner = "bottom_left"
            else
                corner = "bottom_right"
            end
        end
        
        -- Call the layout's mouse resize handler
        layout.mouse_resize_handler(c, corner, initial_coords.x, initial_coords.y)
        return
    end

    -- Fallback to floating window resize for floating clients or layouts without mouse handler
    -- Store initial cursor position
    local initial_coords = mouse.coords()

    -- Store initial client geometry
    local geo = c:geometry()
    local initial_geo = {x = geo.x, y = geo.y, width = geo.width, height = geo.height}

    -- Calculate initial center position
    local center_x = geo.x + geo.width / 2
    local center_y = geo.y + geo.height / 2

    -- Get the current screen's geometry for boundary checking
    local screen_geo = screen[c.screen].geometry

    -- Start the mouse grabber without warping the cursor
    local prev_coords = initial_coords
    mousegrabber.run(function(m)
        if not c.valid then return false end

        -- Calculate offset from initial position (not previous)
        local dx = m.x - initial_coords.x
        local dy = m.y - initial_coords.y

        -- Calculate new dimensions based on mouse distance from initial click for uniform scaling
        local distance = math.sqrt(dx*dx + dy*dy)
        local scale_factor = 1 + (distance - 50) / 200  -- Adjust these values for sensitivity
        if dx < 0 or dy < 0 then scale_factor = 2 - scale_factor end
        scale_factor = math.max(0.1, scale_factor)  -- Prevent making window too small

        local new_width = math.max(50, initial_geo.width * scale_factor)
        local new_height = math.max(50, initial_geo.height * scale_factor)

        -- Calculate new position to keep center fixed
        local new_x = center_x - new_width / 2
        local new_y = center_y - new_height / 2

        -- Check if window would go off screen and adjust only if necessary
        local needs_reposition = false
        if new_x < screen_geo.x then
            new_x = screen_geo.x
            needs_reposition = true
        elseif new_x + new_width > screen_geo.x + screen_geo.width then
            new_x = screen_geo.x + screen_geo.width - new_width
            needs_reposition = true
        end

        if new_y < screen_geo.y then
            new_y = screen_geo.y
            needs_reposition = true
        elseif new_y + new_height > screen_geo.y + screen_geo.height then
            new_y = screen_geo.y + screen_geo.height - new_height
            needs_reposition = true
        end

        -- Update center position only if we had to reposition due to screen boundaries
        if needs_reposition then
            center_x = new_x + new_width / 2
            center_y = new_y + new_height / 2
        end

        -- Apply the new geometry
        c:geometry({
            x = math.floor(new_x),
            y = math.floor(new_y),
            width = math.floor(new_width),
            height = math.floor(new_height)
        })

        return m.buttons[3] or m.buttons[2]  -- Continue as long as right or middle button is pressed
    end, "fleur")

    -- Update center position for our center-locked resizing
    -- once resize is complete
    if c.floating and window_centers then
        local new_geo = c:geometry()
        window_centers[c] = {
            x = new_geo.x + new_geo.width / 2,
            y = new_geo.y + new_geo.height / 2
        }
    end
end

-- // MARK: --floating-window-center
-- FLOATING WINDOW CENTER - maintains the center position of floating windows when they are resized

-- Table to store original centers of windows and whether they're being dragged
local window_centers = {}
local dragging_clients = {}

-- Keep track of which clients are being dragged
client.connect_signal("request::activate", function(c, context, hints)
    -- Check if mouse button is still down
    local buttons = mouse.coords().buttons
    if not buttons or not buttons[1] then
        -- Mouse button released, no longer dragging
        dragging_clients[c] = nil
        -- Store new center position after drag
        local geo = c:geometry()
        window_centers[c] = {
            x = geo.x + geo.width / 2,
            y = geo.y + geo.height / 2
        }
    end
    return true
end)

-- Track when a floating window's size changes
client.connect_signal("property::size", function(c)
    -- Skip if not floating
    if not c.floating then return end

    -- Skip if being dragged
    if is_client_being_dragged(c) then return end

    -- Record center point on first detection
    if not window_centers[c] then
        local geo = c:geometry()
        window_centers[c] = {
            x = geo.x + geo.width / 2,
            y = geo.y + geo.height / 2
        }
        return
    end

    -- Get current geometry and maintain center position
    local geo = c:geometry()
    c:geometry({
        x = window_centers[c].x - geo.width / 2,
        y = window_centers[c].y - geo.height / 2
    })
end)

-- Clean up when windows are closed
client.connect_signal("unmanage", function(c)
    window_centers[c] = nil
    dragging_clients[c] = nil
end)

-- // MARK: --mouse-buttons
-- MOUSE BUTTONS - mouse button bindings
clientbuttons = gears.table.join(
    awful.button({ }, 1, function (c)
        c:emit_signal("request::activate", "mouse_click", {raise = true})
    end),
    awful.button({ modkey }, 1, function (c)
        c:emit_signal("request::activate", "mouse_click", {raise = true})
        awesome_dnd.start_custom_drag(c, {follow_on_drop = false})  -- drag without following
    end),
    awful.button({ modkey, shiftkey }, 1, function (c)
        c:emit_signal("request::activate", "mouse_click", {raise = true})
        awesome_dnd.start_custom_drag(c, {follow_on_drop = true})   -- drag and follow
    end),
    awful.button({ modkey }, 3, function (c)
        c:emit_signal("request::activate", "mouse_click", {raise = true})
        awful.mouse.client.resize(c)
    end),
    awful.button({ modkey }, 4, function() awful.tag.viewnext() end),
    awful.button({ modkey }, 5, function() awful.tag.viewprev() end)
)

-- Middle mouse button for minimize/focus
awful.button({}, 0, function(c)
    if c == client.focus then
        c.minimized = true
    else
        client.focus = c
        c:raise()
    end
end)

-- Set keys
root.keys(globalkeys)

-- shimmer system - placeholder functions for compatibility
-- Note: set_shimmer_mode is already defined globally above
local function test_launcher_color_cycle()
    -- placeholder function - shimmer system not yet implemented  
    naughty.notify({title = "Color Test", text = "Cycling launcher colors (placeholder)", timeout = 1})
end

-- shimmer hotkey bindings (extended)
globalkeys = gears.table.join(globalkeys,
    -- shimmer control keys (currently placeholder functions)
    awful.key({modkey, shiftkey, altkey}, "1", function()
        set_shimmer_mode("candle")
        -- naughty.notify({title = "Shimmer Mode", text = "Candle Flicker", timeout = 2})
    end, {description = "candle shimmer mode", group = "shimmer"}),
    
    awful.key({modkey, shiftkey, altkey}, "2", function()
        set_shimmer_mode("cloud")
        -- naughty.notify({title = "Shimmer Mode", text = "Cloud Shadows", timeout = 2})
    end, {description = "cloud shimmer mode", group = "shimmer"}),
    
    awful.key({modkey, shiftkey, altkey}, "3", function()
        set_shimmer_mode("char_flicker")
        -- naughty.notify({title = "Shimmer Mode", text = "Character Flicker", timeout = 2})
    end, {description = "character flicker shimmer mode", group = "shimmer"}),
    
    awful.key({modkey, shiftkey, altkey}, "4", function()
        set_shimmer_mode("border_sync")
        -- naughty.notify({title = "Shimmer Mode", text = "Border Sync", timeout = 2})
    end, {description = "border sync shimmer mode", group = "shimmer"}),
    
    awful.key({modkey, shiftkey, altkey}, "0", function()
        set_shimmer_mode("off")
        -- naughty.notify({title = "Shimmer Mode", text = "Off", timeout = 2})
    end, {description = "turn off shimmer", group = "shimmer"}),
    
    awful.key({modkey, shiftkey, altkey}, "5", function()
        set_shimmer_mode("deep_gold")
        -- naughty.notify({title = "Shimmer Mode", text = "Deep Gold", timeout = 2})
    end, {description = "deep gold shimmer mode", group = "shimmer"}),
    
    -- test color cycling
    awful.key({modkey, ctrlkey, altkey}, "t", function()
        test_launcher_color_cycle()
        -- naughty.notify({title = "Color Test", text = "Cycling launcher colors", timeout = 1})
    end, {description = "test color cycling", group = "shimmer"})
)

-- Shimmer hotkey bindings (duplicate removed - using the one above)

-- Additional client keybindings
globalkeys = gears.table.join(globalkeys,
    -- Minimize current window
    awful.key({modkey}, "n", function(c)
        -- The client currently has the input focus, so it cannot be
        -- minimized, since minimized clients cant have the focus.
        c.minimized = true
    end, {description = "minimize", group = "client"}),
    
    -- Unminimize next window (duplicate removed - using the one above)
    
    -- Jump to window
    awful.key({modkey, shiftkey}, "n",
    function() awful.util.spawn("/home/milk/bin/rofi_jumpwindow") end,
    {description = "jump to window", group = "client"}),

    -- Maximise toggle for current window
    awful.key({modkey}, "m", function(c)
        c.maximized = not c.maximized
        c:raise()
    end, {description = "(un)maximize", group = "client"}),

    -- Maximise vertically toggle for current window
    awful.key({modkey, ctrlkey}, "m", function(c)
        c.maximized_vertical = not c.maximized_vertical
        c:raise()
    end, {description = "(un)maximize vertically", group = "client"}),

    -- Maximise horizontally toggle for current window
    awful.key({modkey, shiftkey}, "m", function(c)
        c.maximized_horizontal = not c.maximized_horizontal
        c:raise()
    end, {description = "(un)maximize horizontally", group = "client"}),

    -- Centre a floating window
    awful.key({modkey, shiftkey}, "z", function(c)
        awful.placement.centered(c)
    end, {
        description = "centre floating window",
        group = "client"
    }), -- Make a window floating and centre is for zen reading experience

    awful.key({modkey}, "a", function(c)
        c.floating = not c.floating
        c.width = c.screen.geometry.width * 3 / 5
        c.x = c.screen.geometry.x + (c.screen.geometry.width / 5)
        c.height = c.screen.geometry.height * 0.93
        c.y = c.screen.geometry.height * 0.04
    end, {description = "large centre floating window", group = "client" }),

    -- Toggle window on-top
    awful.key({modkey}, "t", function(c) c.ontop = not c.ontop end,
    { description = "toggle keep on top", group = "client" }),
    
    -- Window z-index
    -- Send window to the behind plane
    awful.key({modkey}, "comma", function(c) c.below = not c.below end,
    {description = "behind", group = "client"}),

    -- Send window to the above plane
    awful.key({modkey}, "slash", function(c) c.above = not c.above end,
    { description = "above", group = "client" }),
    
    -- Sticky window, stays on all tags
    awful.key({modkey}, "x", function(c) c.sticky = not c.sticky end,
    {description = "toggle sticky", group = "client"})
)

-- Define tag keybinding combinations in a table for clarity
local tag_keybindings = {
    { mods = {modkey}, action = function(tag) tag:view_only() end, desc = "view tag #%d" },
    { mods = {modkey, altkey}, action = function(tag) awful.tag.viewtoggle(tag) end, desc = "toggle tag #%d" },
    { mods = {modkey, ctrlkey}, action = function(tag) if client.focus then client.focus:move_to_tag(tag) end end, desc = "move client to tag #%d" },
    { mods = {modkey, shiftkey}, action = function(tag) if client.focus then client.focus:move_to_tag(tag); tag:view_only() end end, desc = "move client and follow to tag #%d" },
    { mods = {modkey, ctrlkey, shiftkey}, action = function(tag) if client.focus then client.focus:toggle_tag(tag) end end, desc = "toggle client on tag #%d" },
}

-- Generate keybindings for tags 1-12
for i = 1, 12 do
    for _, binding in ipairs(tag_keybindings) do
        globalkeys = gears.table.join(globalkeys,
            awful.key(binding.mods, "#" .. i + 9, function()
                local s = awful.screen.focused()
                local tag = s.tags[i]
                if tag then
                    binding.action(tag)
                end
            end, {description = binding.desc:format(i), group = "tag"})
        )
    end
end

-- Additional system keybindings
globalkeys = gears.table.join(globalkeys,
    -- Volume Keys
    awful.key({}, "XF86AudioLowerVolume", function() awful.spawn.with_shell("vol-dec-all-3.sh", false) end,
    { description = "decrease volume", group = "hotkeys" }),
    awful.key({}, "XF86AudioRaiseVolume", function() awful.spawn.with_shell("vol-inc-all-3.sh", false) end,
    { description = "increase volume", group = "hotkeys" }),
    awful.key({}, "XF86AudioMute", function() awful.util.spawn("wpctl set-mute @DEFAULT_AUDIO_SINK@ toggle", false) end,
    { description = "toggle mute", group = "hotkeys" }),

    -- Control amplifier hardware
    awful.key({ modkey, ctrlkey, altkey }, "b", function() awful.util.spawn("funiculi --host 192.168.1.24 up", false) end,
    { description = "Denon amp increase volume", group = "hotkeys" }),
    awful.key({ modkey, ctrlkey, altkey }, "g", function() awful.util.spawn("funiculi --host 192.168.1.24 down", false) end,
    { description = "Denon amp decrease volume", group = "hotkeys" }),
    awful.key({ modkey, ctrlkey, altkey }, "v", function() awful.util.spawn("denon_toggle_source.sh", false) end,
    { description = "Denon amp source set toggle", group = "hotkeys" }),
    awful.key({ modkey, ctrlkey, altkey }, "r", function() awful.util.spawn("denon_toggle_power.sh", false) end,
    { description = "Denon amp power toggle", group = "hotkeys" }),

    -- Media keys with Winamp style hotkeys
    awful.key({ modkey, ctrlkey }, "z", function() awful.util.spawn("playerctl previous", false) end,
    { description = "media backwards", group = "mediakeys" }),
    awful.key({}, "XF86AudioPrev", function() awful.util.spawn("playerctl previous", false) end,
    { description = "media backwards", group = "mediakeys"}),
    awful.key({ modkey, ctrlkey }, "x", function() awful.util.spawn("playerctl play", false) end,
    { description = "media play", group = "mediakeys"}),
    awful.key({}, "XF86AudioPlay", function() awful.util.spawn("playerctl play", false) end,
    { description = "media play", group = "mediakeys"}),
    awful.key({ modkey, ctrlkey }, "c", function() awful.util.spawn("playerctl play-pause", false) end,
    { description = "media pause", group = "mediakeys"}),
    awful.key({}, "XF86AudioPause", function() awful.util.spawn("playerctl play-pause", false) end,
    { description = "media pause", group = "mediakeys"}),
    awful.key({ modkey, ctrlkey }, "d", function() awful.util.spawn("playerctl stop", false) end,
    { description = "media stop", group = "mediakeys"}),
    awful.key({}, "XF86AudioStop", function() awful.util.spawn("playerctl stop", false) end,
    { description = "media stop", group = "mediakeys"}),
    awful.key({ modkey, ctrlkey }, "v", function() awful.util.spawn("playerctl next", false) end,
    { description = "media next", group = "mediakeys"}),
    awful.key({}, "XF86AudioNext", function() awful.util.spawn("playerctl next", false) end,
    { description = "media next", group = "mediakeys"}),

    -- Brightness
    awful.key({}, "XF86MonBrightnessDown", function() os.execute("brillo -U 10") end,
    { description = "decrease brightness", group = "hotkeys" }),
    awful.key({ modkey }, "XF86AudioLowerVolume", function() os.execute("brillo -U 10") end,
    { description = "decrease brightness", group = "hotkeys" }),
    awful.key({}, "XF86MonBrightnessUp", function() os.execute("brillo -A 10") end,
    {description = "increase brightness", group = "hotkeys"}),
    awful.key({ modkey }, "XF86AudioRaiseVolume", function() os.execute("brillo -A 10") end,
    {description = "increase brightness", group = "hotkeys"}),

    -- Application launcher
    awful.key({modkey}, "space", function() awful.util.spawn("/home/milk/bin/rofi_nice") end,
    {description = "run rofi app launcher", group = "launcher"}),
    awful.key({modkey, altkey}, "space", function() awful.util.spawn("/home/milk/bin/rofi_nice_run") end,
    {description = "run rofi cmd launcher", group = "launcher"}),

    -- Emoji picker
    awful.key({modkey, altkey}, "e", function() awful.util.spawn("emote") end,
    {description = "run emote emoji picker", group = "launcher"}),

    -- Treetile layout controls
    awful.key({ modkey, altkey }, "v", treetile.vertical),
    awful.key({ modkey, altkey }, "h", treetile.horizontal),

    -- Popup box to enter lua code to run
    awful.key({modkey, shiftkey}, "x", function()
        awful.prompt.run {
            prompt = "Run Lua code: ",
            textbox = awful.screen.focused().mypromptbox.widget,
            exe_callback = awful.util.eval,
            history_path = awful.util.get_cache_dir() .. "/history_eval"
        }
    end, {description = "lua execute prompt", group = "awesome"}),

    -- Hide the statusbar, resizing the window space
    awful.key({modkey}, "v", function()
        myscreen = awful.screen.focused()
        myscreen.mywibox.visible = not myscreen.mywibox.visible
    end, {description = "toggle statusbar", group = "awesome"}),

    -- Hide the status bar, not resizing the window space
    awful.key({modkey, altkey}, "v", function()
        for s in screen do
            s.mywibox.visible = not s.mywibox.visible
            if s.myaltwibox then
                s.myaltwibox.visible = not s.myaltwibox.visible
            end
        end
    end, {description = "toggle wibox", group = "awesome"}),

    -- Menubar app launcher
    awful.key({modkey, shiftkey}, "space", function() menubar.show() end,
    { description = "show the menubar", group = "launcher" })
)

-- Awesome control and layout keybindings
globalkeys = gears.table.join(globalkeys,
    -- Restart awesome (duplicate removed - using the one above)

    -- Quit awesome
    awful.key({modkey, ctrlkey, shiftkey}, "q", function() confirmQuitmenu:show() end, {
    description = "Confirm Awesome wm exit", group = "awesome" }),

    -- Layout management
    awful.key({modkey, shiftkey}, "h", function() awful.tag.incnmaster(1, nil, true) end,
    { description = "increase the number of master clients", group = "layout" }),
    awful.key({modkey, shiftkey}, "l", function() awful.tag.incnmaster(-1, nil, true) end,
    { description = "decrease the number of master clients", group = "layout" }),
    -- Layout column controls (duplicate removed - using the ones above)

    awful.key({modkey}, "r", function() awful.layout.inc(1) end,
    {description = "select next layout", group = "layout"}),
    awful.key({modkey, shiftkey}, "r", function() awful.layout.inc(-1) end,
    {description = "select previous layout", group = "layout"}),

    -- Toggle floating window to the corner
    awful.key({modkey, shiftkey}, "w", function()
        local c = client.focus
        awful.client.floating.toggle()
        if c.floating then
            c.floating = false
            c.ontop = false
            c.sticky = false
        else
            c.floating = true
            c.ontop = true
            c.sticky = true
            c.width = 633
            c.height = 400
            awful.placement.top_right(client.focus)
        end
    end, {description = "ontop floating right corner", group = "client"}),

    -- Edit awesome config
    awful.key({modkey, shiftkey}, "e", function() awful.spawn.raise_or_spawn("urxvt -e sh -c '$EDITOR ~/.config/awesome/rc.lua'", nil, nil, "awesomeconf")
    end, {description = "edit awesome config", group = "launcher"})
)

-- Screen and tag navigation keybindings
globalkeys = gears.table.join(globalkeys,
    -- Screen rotation
    awful.key({modkey, altkey}, "j", function() rotate_screens(1) end,
    {description = "rotate screens left", group = "screen"}),

    awful.key({modkey, altkey}, "k", function() rotate_screens(-1) end,
    { description = "rotate screens right", group = "screen" }),

    -- Tag navigation
    awful.key({modkey, ctrlkey}, "left", function() move_to_previous_tag() end,
    {description = "move client to prev tag without follow", group = "tag"}),

    awful.key({modkey, ctrlkey}, "right", function() move_to_next_tag() end,
    { description = "move client to next tag without follow", group = "tag" })
)

-- Terminal and screen focus keybindings
globalkeys = gears.table.join(globalkeys,
    -- Launch floating terminal
    awful.key({modkey, shiftkey}, "Return", function() awful.spawn(terminal, {floating = true, placement = awful.placement.centered}) end,
    {description = "open a floating terminal", group = "launcher"}),

    -- Launch terminal in current working directory (duplicate removed)

    -- Launch urxvt terminal
    awful.key({ modkey, altkey }, "Return", function () awful.util.spawn("urxvt") end,
    {description = "open urxvt terminal", group = "launcher"}),

    -- Launch Hue lighting sync to screen colours (duplicate removed - using the one above)

    -- Screen focus
    awful.key({modkey}, "o", function() awful.screen.focus_relative(1) end,
    {description = "focus the next screen", group = "screen"}),
    awful.key({modkey}, "u", function() awful.screen.focus_relative(-1) end,
    {description = "focus the previous screen", group = "screen"}),

    -- Add focused window to floating rules (non-interactive)
    awful.key({modkey, ctrlkey, shiftkey}, "f", function()
        awful.spawn.with_shell("/home/milk/dotfiles/awesome/.config/awesome/add-floating-rule.sh")
    end, {description = "add focused window to floating rules", group = "awesome"})
)

-- Client swap and tag access keybindings
globalkeys = gears.table.join(globalkeys,
    -- Client swap by index
    awful.key({modkey, shiftkey}, "j", function() awful.client.swap.byidx(1) end,
        {description = "swap with next client by index", group = "client"}),

    awful.key({modkey, shiftkey}, "k", function() awful.client.swap.byidx(-1) end,
        {description = "swap with previous client by index", group = "client"}),

    -- Direct tag access
    awful.key({modkey}, "0", function() awful.tag.viewidx(10) end,
        {description = "view tag #10", group = "tag"})
)

-- Minimized window cycling keybindings
globalkeys = gears.table.join(globalkeys,
    -- Cycle through minimized windows
    awful.key({modkey, altkey}, "'", function()
        local current_screen = awful.screen.focused()
        local minimized_on_screen = {}
        local focused_client = client.focus
        local focused_is_cyclable = false

        -- Collect all minimized clients on this screen
        for c in awful.client.iterate(function(c)
            return c.minimized and c.screen == current_screen
        end, nil, current_screen) do
            table.insert(minimized_on_screen, c)
        end

        -- Check if focused client can be minimized
        if focused_client and focused_client.screen == current_screen then
            focused_is_cyclable = true
        end

        -- If there is a focused, unminimized client on this screen, minimize it to advance the cycle
        if focused_is_cyclable then
            focused_client.minimized = true
            -- Exclude the client we just minimized from immediate restore if there are others
            if #minimized_on_screen > 1 then
                for i = #minimized_on_screen, 1, -1 do
                    if minimized_on_screen[i] == focused_client then
                        table.remove(minimized_on_screen, i)
                        break
                    end
                end
            end
        end

        -- Restore the most recently encountered minimized client on this screen
        local to_restore = minimized_on_screen[#minimized_on_screen]
        to_restore.minimized = false
        to_restore:emit_signal("request::activate", "key.cycle_minimized.screen", {raise = true})
        client.focus = to_restore
    end, {description = "cycle minimized windows (current screen)", group = "client"}),

    -- Restore all minimized windows
    awful.key({modkey, altkey}, ";", function()
        local current_screen = awful.screen.focused()

        -- Build a fast lookup for selected tags on the current screen
        local selected_tag_by_id = {}
        for _, t in ipairs(current_screen.tags) do
            if t.selected then
                selected_tag_by_id[t] = true
            end
        end

        local function is_on_selected_tag(c)
            if c and c.valid and c.tags then
                for _, t in ipairs(c:tags()) do
                    if t.screen == current_screen and selected_tag_by_id[t] then
                        return true
                    end
                end
            end
            return false
        end

        for c in awful.client.iterate(function(c)
            return c.minimized and c.screen == current_screen and is_on_selected_tag(c)
        end, nil, current_screen) do
            c.minimized = false
            c:emit_signal("request::activate", "key.restore_all.screen", {raise = true})
        end
    end, {description = "restore all minimized windows (current screen)", group = "client"})
)

-- Cyclefocus keybindings
globalkeys = gears.table.join(globalkeys,
    -- Cycle through clients
    awful.key({modkey}, "Tab", function() cyclefocus.cycle({modifier = "Super_L"}) end,
        {description = "cycle through clients", group = "client"}),

    -- Cycle backwards through clients
    awful.key({modkey, shiftkey}, "Tab", function() cyclefocus.cycle({modifier = "Super_L"}) end,
        {description = "cycle backward through clients", group = "client"})
)

-- Tag navigation keybindings
globalkeys = gears.table.join(globalkeys,
    -- View previous non-empty tag
    awful.key({modkey, ctrlkey}, "Left", function()
        local focused = awful.screen.focused()
        for i = 1, #focused.tags do
            awful.tag.viewidx(-1, focused)
            if #focused.clients > 0 then
                return
            end
        end
    end, {description = "view previous non-empty tag", group = "tag"}),

    -- View next non-empty tag
    awful.key({modkey, ctrlkey}, "Right", function()
        local focused = awful.screen.focused()
        for i = 1, #focused.tags do
            awful.tag.viewidx(1, focused)
            if #focused.clients > 0 then
                return
            end
        end
    end, {description = "view next non-empty tag", group = "tag"})
)

-- Awesome control and tag cycling keybindings
globalkeys = gears.table.join(globalkeys,
    -- Blank screen temporarily
    awful.key({modkey, ctrlkey}, "b", function() os.execute("sleep 1; xset dpms force off")
        end, {description = "blank screen(s) temporarily", group = "awesome"}),

    -- Monitor management
    awful.key({modkey, altkey}, "r", function() os.execute("monitor_rofi.sh") end,
        {description = "monitor Rofi menu", group = "awesome"}),

    -- Power menu
    awful.key({modkey, altkey}, "p", function() os.execute("rofi_power") end,
    { description = "power Rofi menu", group = "awesome" }),

    -- Cycle back and forth through tags with clients
    awful.key({modkey}, "Left", function() cycle_tags_with_clients("prev") end,
        {description = "cycle to previous tag with clients", group = "tag"}),

    awful.key({modkey}, "Right", function() cycle_tags_with_clients("next") end,
        {description = "cycle to next tag with clients", group = "tag"})
)


-- // MARK: WINDOWS
-- ################################################################################
-- ██╗    ██╗██╗███╗   ██╗██████╗  ██████╗ ██╗    ██╗███████╗
-- ██║    ██║██║████╗  ██║██╔══██╗██╔═══██╗██║    ██║██╔════╝
-- ██║ █╗ ██║██║██╔██╗ ██║██║  ██║██║   ██║██║ █╗ ██║███████╗
-- ██║███╗██║██║██║╚██╗██║██║  ██║██║   ██║██║███╗██║╚════██║
-- ╚███╔███╔╝██║██║ ╚████║██████╔╝╚██████╔╝╚███╔███╔╝███████║
--  ╚══╝╚══╝ ╚═╝╚═╝  ╚═══╝╚═════╝  ╚═════╝  ╚══╝╚══╝ ╚══════╝
-- ################################################################################
-- WINDOWS - client rules, window management, and behavior


-- signal function to execute when a new client appears
client.connect_signal("manage", function (c)
    -- set the windows at the slave,
    -- i.e. put it at the end of others instead of setting it master.
    -- if not awesome.startup then awful.client.setslave(c) end

    if awesome.startup
      and not c.size_hints.user_position
      and not c.size_hints.program_position then
        -- prevent clients from being unreachable after screen count changes
        awful.placement.no_offscreen(c)
    end
end)

-- add a titlebar if titlebars_enabled is set to true in the rules
client.connect_signal("request::titlebars", function(c)
    -- buttons for the titlebar
    local buttons = gears.table.join(
        awful.button({ }, 1, function()
            c:emit_signal("request::activate", "titlebar", {raise = true})
            awful.mouse.client.move(c)
        end),
        awful.button({ }, 3, function()
            c:emit_signal("request::activate", "titlebar", {raise = true})
            awful.mouse.client.resize(c)
        end)
    )

    awful.titlebar(c) : setup {
        { -- Left
            awful.titlebar.widget.iconwidget(c),
            buttons = buttons,
            layout  = wibox.layout.fixed.horizontal
        },
        { -- Middle
            { -- Title
                align  = "center",
                widget = awful.titlebar.widget.titlewidget(c)
            },
            buttons = buttons,
            layout  = wibox.layout.flex.horizontal
        },
        { -- Right
            awful.titlebar.widget.floatingbutton (c),
            awful.titlebar.widget.maximizedbutton(c),
            awful.titlebar.widget.stickybutton   (c),
            awful.titlebar.widget.ontopbutton    (c),
            awful.titlebar.widget.closebutton    (c),
            layout = wibox.layout.fixed.horizontal()
        },
        layout = wibox.layout.align.horizontal
    }
end)

-- enable sloppy focus, so that focus follows mouse (disabled)
-- client.connect_signal("mouse::enter", function(c)
--     c:emit_signal("request::activate", "mouse_enter", {raise = false})
-- end)

client.connect_signal("focus", function(c) c.border_color = beautiful.border_focus end)
client.connect_signal("unfocus", function(c) c.border_color = beautiful.border_normal end)


-- // MARK: DRAG AND DROP
-- ################################################################################
-- ██████╗ ██████╗ ██████╗  █████╗  ██████╗     ██████╗  ██████╗ ██████╗ 
-- ██╔══██╗██╔══██╗██╔══██╗██╔══██╗██╔════╝    ██╔═══██╗██╔═══██╗██╔══██╗
-- ██║  ██║██████╔╝██║  ██║███████║██║         ██║   ██║██║   ██║██████╔╝
-- ██║  ██║██╔══██╗██║  ██║██╔══██║██║         ██║   ██║██║   ██║██╔═══╝ 
-- ██████╔╝██║  ██║██████╔╝██║  ██║╚██████╗    ╚██████╔╝╚██████╔╝██║     
-- ╚═════╝ ╚═╝  ╚═╝╚═════╝ ╚═╝  ╚═╝ ╚═════╝     ╚═════╝  ╚═════╝ ╚═╝     
-- ################################################################################
-- DRAG AND DROP - client to tag drag and drop functionality


-- // MARK: SIGNALS
-- ################################################################################
-- ███████╗██╗ ██████╗ ███╗   ██╗ █████╗ ██╗     ███████╗
-- ██╔════╝██║██╔════╝ ████╗  ██║██╔══██╗██║     ██╔════╝
-- ███████╗██║██║  ███╗██╔██╗ ██║███████║██║     ███████╗
-- ╚════██║██║██║   ██║██║╚██╗██║██╔══██║██║     ╚════██║
-- ███████║██║╚██████╔╝██║ ╚████║██║  ██║███████╗███████║
-- ╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝  ╚═╝╚══════╝╚══════╝
-- ################################################################################
-- SIGNALS - client and screen signal handlers


-- // MARK: RULES
-- ################################################################################
-- ██████╗ ██╗   ██╗██╗     ███████╗
-- ██╔══██╗██║   ██║██║     ██╔════╝
-- ██████╔╝██║   ██║██║     ███████╗
-- ██╔══██╗██║   ██║██║     ╚════██║
-- ██║  ██║╚██████╔╝███████╗███████║
-- ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚══════╝
-- ################################################################################
-- RULES - client rules and window behavior

-- // MARK: --global-rules
-- rules to apply to new clients (through the "manage" signal)
awful.rules.rules = {
    -- all clients will match this rule (global defaults)
    {
        rule = {},
        properties = {
            border_width = beautiful.border_width,
            border_color = beautiful.border_normal,
            focus = awful.client.focus.filter,
            raise = true,
            keys = clientkeys,
            buttons = clientbuttons,
            screen = awful.screen.preferred,
            placement = awful.placement.no_overlap+awful.placement.no_offscreen
        }
    },

    -- floating clients
    { rule_any = {
            instance = {
          "DTA",  -- Firefox addon DownThemAll.
          "copyq",  -- Includes session name in class.
          "pinentry",
        },
            class = {
          "Arandr",
          "Blueman-manager",
          "Gpick",
          "Kruler",
          "MessageWin",  -- kalarm.
          "Sxiv",
          "Tor Browser", -- Needs a fixed window size to avoid fingerprinting by screen size.
          "Wpa_gui",
          "veromix",
          "xtightvncviewer"},

        -- Note that the name property shown in xprop might be set slightly after creation of the client
        -- and the name shown there might not match defined rules here.
            name = {
          "Event Tester",  -- xev.
        },
            role = {
          "AlarmWindow",  -- Thunderbird's calendar.
          "ConfigManager",  -- Thunderbird's about:config.
          "pop-up",       -- e.g. Google Chrome's (detached) Developer Tools.
        }
      }, properties = { floating = true }},

    -- add titlebars to normal clients and dialogs (disabled)
    -- { rule_any = {type = { "normal", "dialog" }
    --   }, properties = { titlebars_enabled = true }
    -- },

    -- // MARK: --floating-rules
    -- {{{ Floating client rules
    -- Applications that should always be floating windows
    -- Search marker: floatingggggggggg
    {
        rule_any = {
            -- Match by instance name
            instance = {
                "DTA",         -- Firefox addon DownThemAll
                "copyq",       -- Clipboard manager (includes session name in class)
                "pinentry",    -- Password entry dialog
                "ncmpcpp",     -- Music player
                "firefox"      -- Firefox dialogs
            },

            -- Match by class name (organized by category)
            class = {
                -- System utilities
                "Arandr", "Blueman-manager", "Lxappearance", "Gsmartcontrol",
                "hp-toolbox", "Protonvpn-gui", "Syncthing GTK", "netctl-gui",
                "Solaar", "Font-manager", "Font Manager", "qt5ct", "Deskflow",

                -- Audio/Video tools
                "Cadence", "qjackctl", "Studio-controls", "QjackCtl",
                "kmix", "Pavucontrol", "pwvucontrol", "Goodvibes",
                "Drumstick MIDI Monitor", "Audio/MIDI Setup", "Mixer",
                "seq64", "qseq66", "patroneo", "Agordejo", "radium_compessor",
                "Vlc", "vokoscreenNG", "SimpleScreenRecorder", "Indicator-sound-switcher5",

                -- Image & Graphics
                "Gpick", "Kruler", "emulsion", "Sxiv", "qimgv", "qView",
                "Image Lounge", "Image Menu", "spectacle", "flameshot",

                -- Security & Privacy
                "KeePassXC", "Tor Browser", -- Tor needs fixed window size to avoid fingerprinting

                -- Misc applications
                "MessageWin",  -- kalarm
                "copyq", "* Copying", "krunner", "xtightvncviewer",
                "scrcpy", "Gnaural", "kdeconnect.sms", "Mattermost",
                "Onboard", "gammy", "Flirc", "isoimagewriter", "Xdotoolgui.py",
                "mpd218 editor.exe", "Indicator-sound-switcher", "easyeffects"
            },

            -- Match by window name (when class/instance isn't reliable)
            -- Note: The name property might be set slightly after client creation
            name = {
                "Event Tester",        -- xev
                "Choose an application", -- DoubleCMD dialog
                "File operations",      -- DoubleCMD dialog
                "Blender Preferences",
                "Options",
                "Tree View Menu",
                "menu"                  -- Rekordbox
            },

            -- Match by window role
            role = {
                "AlarmWindow",   -- Thunderbird calendar
                "ConfigManager", -- Thunderbird about:config
                "pop-up",       -- e.g., Chrome's Developer Tools
                "page-info",    -- Firefox page info dialog
                "TfrmFileOp",    -- DoubleCMD file transfer
                "TfrmViewer"     -- DoubleCMD text viewer
            }
        },
        properties = {
            floating = true,  -- Make these windows floating
            placement = awful.placement.centered +       -- Center on screen
                        awful.placement.no_overlap +     -- Prevent overlap
                        awful.placement.no_offscreen     -- Keep on screen
        }
    },

    -- Focus filter rule
    {rule = {}, properties = {focus = awful.client.focus.filter}},
    -- Alternative: {rule = {}, properties = {focus = true}},
    

    -- // MARK: --tag-assignments
    -- {{{ Application-specific tag assignments
    -- Custom callback to set class
    {
        rule = {class = "URxvt", instance = "ncmpcpp"},
        callback = function(c) c.overwrite_class = "urxvt:dev" end
    },

    -- Tag 2: Audio production
    { rule = {instance = "Agordejo"}, properties = {tag = "2"} },
    { rule = {instance = "raysession"}, properties = {tag = "2"} },

    -- Tag 3: File sharing & media management
    { rule = {instance = "Nicotine"}, properties = {tag = "3"} },
    { rule = {instance = "qbittorrent"}, properties = {tag = "3"} },
    { rule = {class = "Picard"}, properties = {tag = "3"} },

    -- Tag 4: DJ software
    { rule = {class = "Mixxx"}, properties = {tag = "4"} },

    -- Tag 8: Music & video playback
    { rule = {instance = "ncmpcpp"}, properties = {tag = "8"} },
    { rule = {instance = "spotify"}, properties = {tag = "8"} },
    { rule = {instance = "Spotify"}, properties = {tag = "8"} },
    { rule = {class = "mpv"}, properties = {screen = 1, tag = "8", switch_to_tags = true} },

    -- Tag 9: File managers
    { rule = {instance = "Double Commander"}, properties = {tag = "9"} },
    { rule = {instance = "doublecmd"}, properties = {tag = "9"} },

    -- Tag "-": Chat applications
    { rule = {instance = "quassel"}, properties = {tag = "-", switch_to_tags = true} },

    -- Tag "=": Web browsers
    { rule_any = {instance = "firefox"}, properties = {tag = "=", switch_to_tags = true} },
    { rule = {class = "firefox"}, properties = {tag = "=", switch_to_tags = true} },
    { rule = {class = "Firefox"}, properties = {tag = "=", switch_to_tags = true} },
    { rule = {class = "Chromium"}, properties = {tag = "=", switch_to_tags = true} },
    { rule = {class = "Navigator"}, properties = {tag = "=", switch_to_tags = true} },
    
    -- More Tag assignments
    { rule = {instance = "jack_mixer"}, properties = {tag = "3"} },
    { rule = {instance = "radium_compressor"}, properties = {tag = "2"} },
    { rule = {instance = "qseq64"}, properties = {tag = "3"} },
    { rule = {instance = "qseq66"}, properties = {tag = "3"} },

-- }}} -- End of application-specific tag assignments

    -- // MARK: --window-sizing
    -- {{{ Window size management rules
    -- Dialogs and windows that should open at larger sizes than default
--     -- Screenshot and image-related dialogs
--     {
--         rule_any = {
--             name = {
--                 "Save screenshot", "Save Screenshot", "Screenshot", "Save Image",
--                 "Save As", "Save File", "Export Image", "Export Screenshot",
--                 "Image Properties", "Image Info", "Screenshot Options"
--             }
--         },
--         properties = {
--             floating = true,
--             width = 800,
--             height = 600,
--             placement = awful.placement.centered + awful.placement.no_overlap + awful.placement.no_offscreen
--         }
--     },

--     -- File operation dialogs
--     {
--         rule_any = {
--             name = {
--                 "Save As", "Open File", "Choose File", "File Operations",
--                 "Copy Files", "Move Files", "Delete Files", "File Properties",
--                 "Folder Properties", "Create Folder", "Rename"
--             }
--         },
--         properties = {
--             floating = true,
--             width = 900,
--             height = 700,
--             placement = awful.placement.centered + awful.placement.no_overlap + awful.placement.no_offscreen
--         }
--     },

--     -- Application preferences and settings dialogs
--     {
--         rule_any = {
--             name = {
--                 "Preferences", "Settings", "Options", "Configuration",
--                 "Properties", "Advanced Settings", "User Preferences",
--                 "Application Settings", "System Preferences"
--             }
--         },
--         properties = {
--             floating = true,
--             width = 850,
--             height = 650,
--             placement = awful.placement.centered + awful.placement.no_overlap + awful.placement.no_offscreen
--         }
--     },

--     -- Print and export dialogs
--     {
--         rule_any = {
--             name = {
--                 "Print", "Print Setup", "Print Options", "Print Preview",
--                 "Export", "Export As", "Export Options", "Save for Web",
--                 "Print to File", "Print Settings"
--             }
--         },
--         properties = {
--             floating = true,
--             width = 750,
--             height = 550,
--             placement = awful.placement.centered + awful.placement.no_overlap + awful.placement.no_offscreen
--         }
--     },

--     -- Error and confirmation dialogs
--     {
--         rule_any = {
--             name = {
--                 "Error", "Warning", "Confirmation", "Confirm Action",
--                 "Delete Confirmation", "Overwrite Confirmation", "Exit Confirmation",
--                 "Unsaved Changes", "Save Changes", "Discard Changes"
--             }
--         },
--         properties = {
--             floating = true,
--             width = 500,
--             height = 300,
--             placement = awful.placement.centered + awful.placement.no_overlap + awful.placement.no_offscreen
--         }
--     },

--     -- Browser dialogs (Firefox, Chrome, etc.)
--     {
--         rule_any = {
--             name = {
--                 "Downloads", "Download Manager", "Bookmarks", "History",
--                 "Add Bookmark", "Edit Bookmark", "Page Info", "Security Info",
--                 "Developer Tools", "Inspect Element", "Console"
--             }
--         },
--         properties = {
--             floating = true,
--             width = 800,
--             height = 600,
--             placement = awful.placement.centered + awful.placement.no_overlap + awful.placement.no_offscreen
--         }
--     },

--     -- Media player dialogs
--     {
--         rule_any = {
--             name = {
--                 "Media Info", "Track Info", "Album Info", "Playlist",
--                 "Add to Playlist", "Create Playlist", "Media Properties",
--                 "Audio Settings", "Video Settings", "Subtitle Settings"
--             }
--         },
--         properties = {
--             floating = true,
--             width = 700,
--             height = 500,
--             placement = awful.placement.centered + awful.placement.no_overlap + awful.placement.no_offscreen
--         }
--     },

--     -- Development and coding dialogs
--     {
--         rule_any = {
--             name = {
--                 "Debug", "Debug Console", "Output", "Terminal",
--                 "Build Output", "Compile Output", "Error List",
--                 "Find in Files", "Replace in Files", "Search Results"
--             }
--         },
--         properties = {
--             floating = true,
--             width = 900,
--             height = 700,
--             placement = awful.placement.centered + awful.placement.no_overlap + awful.placement.no_offscreen
--         }
--     },

--     -- Generic large dialogs (catch-all for other dialogs)
--     {
--         rule_any = {
--             type = { "dialog" }
--         },
--         properties = {
--             floating = true,
--             width = 600,
--             height = 400,
--             placement = awful.placement.centered + awful.placement.no_overlap + awful.placement.no_offscreen
--         }
--     }
    
-- }}} -- End of window size management rules
}


-- // MARK: RUNTIME
-- ################################################################################
-- ██████╗ ██╗   ██╗███╗   ██╗████████╗██╗███╗   ███╗███████╗
-- ██╔══██╗██║   ██║████╗  ██║╚══██╔══╝██║████╗ ████║██╔════╝
-- ██████╔╝██║   ██║██╔██╗ ██║   ██║   ██║██╔████╔██║███████╗
-- ██╔══██╗██║   ██║██║╚██╗██║   ██║   ██║██║╚██╔╝██║██╔══╝  
-- ██║  ██║╚██████╔╝██║ ╚████║   ██║   ██║██║ ╚═╝ ██║███████╗
-- ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═══╝   ╚═╝   ╚═╝╚═╝     ╚═╝╚══════╝
-- ################################################################################
-- RUNTIME - runtime configuration, drag-and-drop, and system settings

-- // MARK: --drag-and-drop
-- Drag-and-drop client → tag (global state and helpers)
-- =====================================================
awesome_dnd = awesome_dnd or {
    dragged_client = nil,
    hovered_tag = nil,
    hovered_widget = nil,
    _timer = nil,
}

function awesome_dnd.clear_hover()
    local widget_to_clear = awesome_dnd.hovered_widget
    
    if widget_to_clear then
        local widget_valid = widget_to_clear.valid
        if widget_valid == nil then
            widget_valid = true -- assume valid if no valid property
        end
        
        if widget_valid then
            if widget_to_clear.__dnd_prev_bg ~= nil then
                widget_to_clear.bg = widget_to_clear.__dnd_prev_bg
                widget_to_clear.__dnd_prev_bg = nil
            else
                widget_to_clear.bg = nil
            end
            if widget_to_clear.__dnd_prev_fg ~= nil then
                widget_to_clear.fg = widget_to_clear.__dnd_prev_fg
                widget_to_clear.__dnd_prev_fg = nil
            end
        end
    end
    awesome_dnd.hovered_tag = nil
    awesome_dnd.hovered_widget = nil
end

function awesome_dnd.set_hover(tag, widget)
    -- Clear previous hover first
    awesome_dnd.clear_hover()
    
    -- Set new hover
    awesome_dnd.hovered_tag = tag
    awesome_dnd.hovered_widget = widget
    
    -- Apply styling the same way normal hover works
    if widget then
        widget.__dnd_prev_bg = widget.bg
        widget.__dnd_prev_fg = widget.fg
        local hover_bg = "#2e7d32" -- dark green
        local hover_fg = "#b8860b" -- gold text
        widget.bg = hover_bg
        widget.fg = "#000000" -- black text on green during drag
        
        -- Force widget update
        if widget.emit_signal then
            widget:emit_signal("widget::redraw_needed")
        end
    end
end

-- completely custom drag mode that doesn't interfere with awesome's built-in systems
function awesome_dnd.start_custom_drag(c, opts)
    if not c or not c.valid then return end
    
    awesome_dnd.dragged_client = c
    
    -- set visual feedback immediately
    c._dnd_prev_border_color = c.border_color
    local dnd_border = beautiful.dnd_border_color or "#2ecc71" -- green
    c.border_color = dnd_border
    c._dnd_dragging = true
    
    -- global drag flag (also used by border animation to pause)
    awesome_dnd.drag_active = true
    awesome_dnd._follow_on_drop = opts and opts.follow_on_drop or false
    
    -- prevent text selection in client (best-effort)
    c.input_passthrough = true
    
    -- force stop any border animation
    if border_animation_timer and border_animation_timer.started then
        border_animation_timer:stop()
        awesome_dnd._paused_border_anim = true
    end
    
    -- use mousegrabber to capture pointer and set cursor during drag
    mousegrabber.run(function(m)
        if not c.valid then
            awesome_dnd.finish_custom_drag()
            return false
        end
        -- detect shift follow-on-drop via modifiers if available
        if m.modifiers then
            awesome_dnd._follow_on_drop = m.modifiers.Shift or m.modifiers["Shift_L"] or m.modifiers["Shift_R"] or false
        end
        -- continuously update hovered tag
        if awesome_dnd.update_hover_from_mouse then
            awesome_dnd.update_hover_from_mouse()
        end
        -- stop on left button release
        if not (m.buttons and m.buttons[1]) then
            awesome_dnd.finish_custom_drag()
            return false
        end
        return true
    end, "hand2")
end

function awesome_dnd.finish_custom_drag()
    -- ensure any overlay/keygrabber are gone (legacy cleanup)
    if awesome_dnd._overlay and awesome_dnd._overlay.valid then awesome_dnd._overlay.visible = false end
    awesome_dnd._overlay = nil
    if awesome_dnd._drag_keygrabber then awesome_dnd._drag_keygrabber:stop() end
    awesome_dnd._drag_keygrabber = nil
    
    local c = awesome_dnd.dragged_client
    local target_tag = awesome_dnd.hovered_tag
    local follow = awesome_dnd._follow_on_drop
    
    -- perform the drop
    if c and c.valid and target_tag and target_tag.valid then
        local old_tag = c.first_tag
        c:move_to_tag(target_tag)
        if follow then
            target_tag:view_only()
        end
        -- update tag squares immediately
        awesome.emit_signal('tag::clients_updated')
        -- if old tag lost its last visible client, give new tag shimmer and clear old
        if old_tag and old_tag.valid then
            local had_visible = false
            for _, cc in ipairs(old_tag:clients()) do
                if not cc.minimized and not cc.hidden then had_visible = true break end
            end
            if not had_visible then
                -- apply shimmer to new tag label
                if target_tag.screen and target_tag.screen.mytaglist then
                    target_tag.screen.mytaglist:emit_signal("widget::redraw_needed")
                end
            end
        end
    else
        -- no notification
    end
    
    -- restore client appearance and input
    if c and c.valid then
        if c._dnd_prev_border_color then
            c.border_color = c._dnd_prev_border_color
            c._dnd_prev_border_color = nil
        end
        c._dnd_dragging = nil
        c.input_passthrough = false -- restore normal input
    end
    
    -- restart border animation if it was paused
    if awesome_dnd._paused_border_anim and border_animation_timer then
        border_animation_timer:start()
        awesome_dnd._paused_border_anim = false
    end
    
    -- clear visual feedback and state
    awesome_dnd.clear_tag_hover()
    awesome_dnd.dragged_client = nil
    awesome_dnd.hovered_tag = nil
    awesome_dnd.drag_active = false
    awesome_dnd._follow_on_drop = nil
end

-- simpler tag detection that just checks screen taglist areas
function awesome_dnd.check_tag_hover_simple(mouse_coords)
    local found_tag = nil
    local prev_hovered = awesome_dnd.hovered_tag
    
    -- check each screen's taglist area
    for s in screen do
        if s.mywibox and s.mywibox.visible then
            local geo = s.mywibox:geometry()
            
            if geo and mouse_coords.x >= geo.x and mouse_coords.x <= geo.x + geo.width and
               mouse_coords.y >= geo.y and mouse_coords.y <= geo.y + geo.height then
                
                -- mouse is over this screen's wibar
                local tag_count = #s.tags
                
                if tag_count > 0 then
                    local relative_x = mouse_coords.x - geo.x
                    
                    -- try to find actual taglist widget to get its real geometry
                    if s.mytaglist and s.mytaglist.visible and s.mytaglist.geometry then
                        local ok, taglist_geo = pcall(function() return s.mytaglist:geometry() end)
                        if ok and taglist_geo then
                            -- check if mouse is within taglist bounds
                            local taglist_rel_x = mouse_coords.x - taglist_geo.x
                            if taglist_rel_x >= 0 and taglist_rel_x <= taglist_geo.width and
                               mouse_coords.y >= taglist_geo.y and mouse_coords.y <= taglist_geo.y + taglist_geo.height then
                                
                                local tag_width = taglist_geo.width / tag_count
                                local tag_index = math.max(1, math.min(tag_count, math.floor(taglist_rel_x / tag_width) + 1))
                                found_tag = s.tags[tag_index]
                            end
                        else
                            -- fallback to estimation
                            local taglist_width = math.min(geo.width * 0.4, tag_count * 60)
                            if relative_x >= 0 and relative_x <= taglist_width then
                                local tag_width = taglist_width / tag_count
                                local tag_index = math.max(1, math.min(tag_count, math.floor(relative_x / tag_width) + 1))
                                found_tag = s.tags[tag_index]
                            end
                        end
                    end
                end
            end
        end
        
        -- update hover state and visual feedback
        if found_tag ~= prev_hovered then
            -- clear previous hover
            awesome_dnd.clear_tag_hover()
            
            if found_tag then
                awesome_dnd.hovered_tag = found_tag
                awesome_dnd.set_tag_hover(found_tag)
            else
                awesome_dnd.hovered_tag = nil
            end
        end
    end
end

-- visual feedback for tag hover during drag
function awesome_dnd.set_tag_hover(tag)
    if not tag or not tag.valid then 
        return 
    end
    
    -- find tag widgets and apply hover background
    for s in screen do
        if s.mytaglist then
            if s.mytaglist._private and s.mytaglist._private.widgets then
                for i, widget_data in pairs(s.mytaglist._private.widgets) do
                    if widget_data.tag == tag and widget_data.widget then
                        -- try different approaches to find background widget
                        local bg_widget = widget_data.widget:get_children_by_id("background_role")[1]
                        if not bg_widget then
                            bg_widget = widget_data.widget:get_children_by_id("tag_bg")[1]
                        end
                        if not bg_widget then
                            -- try the widget itself
                            bg_widget = widget_data.widget
                        end
                        
                        if bg_widget then
                            bg_widget._dnd_original_bg = bg_widget.bg
                            bg_widget._dnd_original_fg = bg_widget.fg
                            bg_widget.bg = beautiful.taglist_dnd_hover_bg or "#b8860b"
                            bg_widget.fg = "#000000" -- black text on gold during drag
                            awesome_dnd._hovered_widget = bg_widget
                        end
                        break
                    end
                end
            end
        end
    end
end

function awesome_dnd.clear_tag_hover()
    if awesome_dnd._hovered_widget then
        if awesome_dnd._hovered_widget._dnd_original_bg then
            awesome_dnd._hovered_widget.bg = awesome_dnd._hovered_widget._dnd_original_bg
            awesome_dnd._hovered_widget._dnd_original_bg = nil
        else
            awesome_dnd._hovered_widget.bg = nil
        end
        if awesome_dnd._hovered_widget._dnd_original_fg then
            awesome_dnd._hovered_widget.fg = awesome_dnd._hovered_widget._dnd_original_fg
            awesome_dnd._hovered_widget._dnd_original_fg = nil
        end
        awesome_dnd._hovered_widget = nil
    end
end



function awesome_dnd.finish_drop()
    local c = awesome_dnd.dragged_client
    if not c or (c.valid ~= nil and not c.valid) then
        awesome_dnd.clear_hover()
        if c and c._dnd_prev_border_color then
            c.border_color = c._dnd_prev_border_color
            c._dnd_prev_border_color = nil
        end
        awesome_dnd.dragged_client = nil
        if awesome_dnd._timer then
            awesome_dnd._timer:stop()
            awesome_dnd._timer = nil
        end
        return
    end

    local t = awesome_dnd.resolve_drop_target and awesome_dnd.resolve_drop_target() or awesome_dnd.hovered_tag
    awesome_dnd.dragged_client = nil
    if t and t.valid and c.valid then
        c:move_to_tag(t)
        -- debug removed
    end
    awesome_dnd.clear_hover()
    if c and c._dnd_prev_border_color then
        c.border_color = c._dnd_prev_border_color
        c._dnd_prev_border_color = nil
        c._dnd_dragging = nil -- clear drag flag
    end
    if awesome_dnd._paused_border_anim and border_animation_timer then
        border_animation_timer:start()
        awesome_dnd._paused_border_anim = false
    end
    if awesome_dnd._timer then
        awesome_dnd._timer:stop()
        awesome_dnd._timer = nil
    end
end

-- attempt to infer hovered tag from the mouse pointer, even during client move
function awesome_dnd.update_hover_from_mouse()
    local mc = mouse.coords()
    if not mc then
        -- debug removed: no mouse coords
        awesome_dnd.clear_hover()
        return
    end
    -- debug removed: mouse position
    local candidates = {}
    -- scan all screens' wibars to be safe (pointer grab may affect mouse.screen)
    for scr in screen do
        if scr.mywibox and scr.mywibox.visible then table.insert(candidates, scr.mywibox) end
        if scr.myaltwibox and scr.myaltwibox.visible then table.insert(candidates, scr.myaltwibox) end
    end
    -- debug removed: number of wibars
    local found_widget, found_tag
    for _, wb in ipairs(candidates) do
        if wb and wb.valid then
            local geo = wb:geometry() or { x = wb.x or 0, y = wb.y or 0, width = wb.width or 0, height = wb.height or 0 }
            local wx = mc.x - geo.x
            local wy = mc.y - geo.y
            -- debug removed: wibar geo, inside wibar
            local list = {}
            if wb.find_widgets then
                local ok, res = pcall(function() return wb:find_widgets(wx, wy) end)
                if ok and res then list = res end
            end
            if (#list == 0) and wb.widget and wb.widget.find_widgets then
                local ok2, res2 = pcall(function() return wb.widget:find_widgets(wx, wy) end)
                if ok2 and res2 then list = res2 end
            end
            for _, item in ipairs(list) do
                local w = item.widget or item
                if w and w._is_dnd_tag_target and w._tag_ref and w._tag_ref.valid then
                    found_widget = (w._dnd_highlight_widget and w._dnd_highlight_widget.valid) and w._dnd_highlight_widget or w
                    found_tag = w._tag_ref
                    break
                end
            end
        end
        if found_tag then break end
    end
    if found_tag then
        awesome_dnd.set_hover(found_tag, found_widget)
    else
        -- Clear hover when no tag is found (mouse moved off tags)
        awesome_dnd.clear_hover()
    end
end

function awesome_dnd.resolve_drop_target()
    if awesome_dnd.hovered_tag and awesome_dnd.hovered_tag.valid then
        return awesome_dnd.hovered_tag
    end
    local mc = mouse.coords()
    if not mc then return nil end
    local candidates = {}
    for scr in screen do
        if scr.mywibox and scr.mywibox.visible then table.insert(candidates, scr.mywibox) end
        if scr.myaltwibox and scr.myaltwibox.visible then table.insert(candidates, scr.myaltwibox) end
    end
    for _, wb in ipairs(candidates) do
        if wb and wb.valid then
            local geo = wb:geometry() or { x = wb.x or 0, y = wb.y or 0, width = wb.width or 0, height = wb.height or 0 }
            local wx = mc.x - geo.x
            local wy = mc.y - geo.y
            if wx >= 0 and wy >= 0 and wx < geo.width and wy < geo.height then
                local list = nil
                if wb.find_widgets then
                    list = wb:find_widgets(wx, wy)
                end
                if (not list or #list == 0) and wb.widget and wb.widget.find_widgets then
                    list = wb.widget:find_widgets(wx, wy)
                end
                list = list or {}
                for _, item in ipairs(list) do
                    local w = item.widget or item
                    if w and w._is_dnd_tag_target and w._tag_ref and w._tag_ref.valid then
                        return w._tag_ref
                    end
                end
            end
        end
    end
    return nil
end

function awesome_dnd.finish_drop()
    local c = awesome_dnd.dragged_client
    if not c or (c.valid ~= nil and not c.valid) then
        awesome_dnd.clear_hover()
        if c and c._dnd_prev_border_color then
            c.border_color = c._dnd_prev_border_color
            c._dnd_prev_border_color = nil
        end
        awesome_dnd.dragged_client = nil
        if awesome_dnd._timer then
            awesome_dnd._timer:stop()
            awesome_dnd._timer = nil
        end
        return
    end
    
    local t = awesome_dnd.resolve_drop_target and awesome_dnd.resolve_drop_target() or awesome_dnd.hovered_tag
    awesome_dnd.dragged_client = nil
    if t and t.valid and c.valid then
        c:move_to_tag(t)
        -- debug removed
    end
    awesome_dnd.clear_hover()
    if c and c._dnd_prev_border_color then
        c.border_color = c._dnd_prev_border_color
        c._dnd_prev_border_color = nil
        c._dnd_dragging = nil -- clear drag flag
    end
    if awesome_dnd._paused_border_anim and border_animation_timer then
        border_animation_timer:start()
        awesome_dnd._paused_border_anim = false
    end
    if awesome_dnd._timer then
        awesome_dnd._timer:stop()
        awesome_dnd._timer = nil
    end
end



-- // MARK: CONFIG
-- ################################################################################
--  ██████╗ ██████╗ ███╗   ██╗███████╗██╗ ██████╗
-- ██╔════╝██╔═══██╗████╗  ██║██╔════╝██║██╔════╝
-- ██║     ██║   ██║██╔██╗ ██║█████╗  ██║██║  ███╗
-- ██║     ██║   ██║██║╚██╗██║██╔══╝  ██║██║   ██║
-- ╚██████╗╚██████╔╝██║ ╚████║███████╗██║╚██████╔╝
--  ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝╚═╝ ╚═════╝
-- ################################################################################
-- CONFIG - final configuration settings and system preferences

-- Color settings
beautiful.bg_systray = "#000000"
-- beautiful.bg_systray = "#191919"
beautiful.notification_bg = "#FFD700"  -- Gold background
beautiful.notification_fg = "#000000"  -- Black text
beautiful.hotkeys_modifiers_fg = "#dddddd"

-- Notification settings
naughty.config.defaults.ontop = true
-- naughty.config.defaults.timeout = 10
-- naughty.config.defaults.margin = dpi("16")
-- naughty.config.defaults.border_width = 0
naughty.config.defaults.width = 400  -- Width in pixels instead of percentage string
naughty.config.defaults.position = 'bottom_middle'

-- Notification icon settings
-- Attempt to constrain the size of large icons in their apps notifications
beautiful.notification_icon_size = 64  -- Number instead of string
naughty.config.defaults['icon_size'] = 64

-- // MARK: START
-- ################################################################################
-- ███████╗████████╗ █████╗ ██████╗ ████████╗
-- ██╔════╝╚══██╔══╝██╔══██╗██╔══██╗╚══██╔══╝
-- ███████╗   ██║   ███████║██████╔╝   ██║   
-- ╚════██║   ██║   ██╔══██╗██╔══██╗   ██║   
-- ███████╗   ██║   ██║  ██║██║  ██║   ██║   
-- ╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   
-- ################################################################################
-- START - Autostart applications

-- Run programs on startup
awful.spawn.with_shell("pgrep -u $USER -x picom > /dev/null || picom --config ~/.config/picom.conf &")

-- Screen layouts
-- awful.spawn.with_shell("~/.screenlayout/new/31-laptop-tv-side.sh")

-- Network manager applet
-- awful.spawn.with_shell("nm-applet")

-- Bluetooth applet
-- awful.spawn.with_shell("blueman-applet")

-- Volume control
-- awful.spawn.with_shell("volumeicon")

-- Clipboard manager
-- awful.spawn.with_shell("clipit")

-- Notifications daemon
-- awful.spawn.with_shell("dunst")

-- Uncomment any of the above or add your own autostart applications

-- Function to restart shimmer timer (useful for debugging)
local function restart_shimmer()
    if shimmer_timer then
        shimmer_timer:stop()
        shimmer_timer.timeout = shimmer_config[shimmer_mode].speed
        shimmer_timer:again()
        -- print("Shimmer timer restarted with mode:", shimmer_mode, "speed:", shimmer_config[shimmer_mode].speed)
    end
end

-- Restart shimmer timer after configuration changes
restart_shimmer()



